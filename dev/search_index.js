var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LibAwsCommon","category":"page"},{"location":"#LibAwsCommon","page":"Home","title":"LibAwsCommon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LibAwsCommon.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LibAwsCommon]","category":"page"},{"location":"#LibAwsCommon.AWS_CBOR_TAG_DECIMAL_FRACTION","page":"Home","title":"LibAwsCommon.AWS_CBOR_TAG_DECIMAL_FRACTION","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_CBOR_TAG_EPOCH_TIME","page":"Home","title":"LibAwsCommon.AWS_CBOR_TAG_EPOCH_TIME","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_CBOR_TAG_NEGATIVE_BIGNUM","page":"Home","title":"LibAwsCommon.AWS_CBOR_TAG_NEGATIVE_BIGNUM","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_CBOR_TAG_STANDARD_TIME","page":"Home","title":"LibAwsCommon.AWS_CBOR_TAG_STANDARD_TIME","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_CBOR_TAG_UNSIGNED_BIGNUM","page":"Home","title":"LibAwsCommon.AWS_CBOR_TAG_UNSIGNED_BIGNUM","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_CRT_STATISTICS_CATEGORY_STRIDE","page":"Home","title":"LibAwsCommon.AWS_CRT_STATISTICS_CATEGORY_STRIDE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_C_COMMON_PACKAGE_ID","page":"Home","title":"LibAwsCommon.AWS_C_COMMON_PACKAGE_ID","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_ERROR_ENUM_STRIDE","page":"Home","title":"LibAwsCommon.AWS_ERROR_ENUM_STRIDE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_ERROR_ENUM_STRIDE_BITS","page":"Home","title":"LibAwsCommon.AWS_ERROR_ENUM_STRIDE_BITS","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_LEVEL_DEBUG","page":"Home","title":"LibAwsCommon.AWS_LOG_LEVEL_DEBUG","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_LEVEL_ERROR","page":"Home","title":"LibAwsCommon.AWS_LOG_LEVEL_ERROR","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_LEVEL_FATAL","page":"Home","title":"LibAwsCommon.AWS_LOG_LEVEL_FATAL","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_LEVEL_INFO","page":"Home","title":"LibAwsCommon.AWS_LOG_LEVEL_INFO","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_LEVEL_NONE","page":"Home","title":"LibAwsCommon.AWS_LOG_LEVEL_NONE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_LEVEL_TRACE","page":"Home","title":"LibAwsCommon.AWS_LOG_LEVEL_TRACE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_LEVEL_WARN","page":"Home","title":"LibAwsCommon.AWS_LOG_LEVEL_WARN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_LOG_SUBJECT_STRIDE","page":"Home","title":"LibAwsCommon.AWS_LOG_SUBJECT_STRIDE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_OP_ERR","page":"Home","title":"LibAwsCommon.AWS_OP_ERR","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_OP_SKIP","page":"Home","title":"LibAwsCommon.AWS_OP_SKIP","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_OP_SUCCESS","page":"Home","title":"LibAwsCommon.AWS_OP_SUCCESS","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_PACKAGE_SLOTS","page":"Home","title":"LibAwsCommon.AWS_PACKAGE_SLOTS","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_PATH_DELIM","page":"Home","title":"LibAwsCommon.AWS_PATH_DELIM","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_PATH_DELIM_STR","page":"Home","title":"LibAwsCommon.AWS_PATH_DELIM_STR","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_TESTING_REPORT_FD","page":"Home","title":"LibAwsCommon.AWS_TESTING_REPORT_FD","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.AWS_THREAD_NAME_RECOMMENDED_STRLEN","page":"Home","title":"LibAwsCommon.AWS_THREAD_NAME_RECOMMENDED_STRLEN","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.FAILURE","page":"Home","title":"LibAwsCommon.FAILURE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.FAIL_PREFIX","page":"Home","title":"LibAwsCommon.FAIL_PREFIX","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.PRInSTR","page":"Home","title":"LibAwsCommon.PRInSTR","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.SIZE_BITS","page":"Home","title":"LibAwsCommon.SIZE_BITS","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.SKIP","page":"Home","title":"LibAwsCommon.SKIP","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.SUCCESS","page":"Home","title":"LibAwsCommon.SUCCESS","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsCommon.__JL_Ctag_1","page":"Home","title":"LibAwsCommon.__JL_Ctag_1","text":"__JL_Ctag_1\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__JL_Ctag_113","page":"Home","title":"LibAwsCommon.__JL_Ctag_113","text":"__JL_Ctag_113\n\nEach library gets space for 2^^8 category entries\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__JL_Ctag_145","page":"Home","title":"LibAwsCommon.__JL_Ctag_145","text":"__JL_Ctag_145\n\n36 bytes for the UUID plus one more for the null terminator.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__JL_Ctag_31","page":"Home","title":"LibAwsCommon.__JL_Ctag_31","text":"__JL_Ctag_31\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__JL_Ctag_42","page":"Home","title":"LibAwsCommon.__JL_Ctag_42","text":"__JL_Ctag_42\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__JL_Ctag_93","page":"Home","title":"LibAwsCommon.__JL_Ctag_93","text":"__JL_Ctag_93\n\nEach library gets space for 2^^10 log subject entries\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__JL_Ctag_94","page":"Home","title":"LibAwsCommon.__JL_Ctag_94","text":"__JL_Ctag_94\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.___itt_track_group_type","page":"Home","title":"LibAwsCommon.___itt_track_group_type","text":"___itt_track_group_type\n\nexclude_from_documentation\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.___itt_track_type","page":"Home","title":"LibAwsCommon.___itt_track_type","text":"___itt_track_type\n\nPlaceholder for custom track types. Currently, \"normal\" custom track is the only available track type.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__clock_t","page":"Home","title":"LibAwsCommon.__clock_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_av_data_type","page":"Home","title":"LibAwsCommon.__itt_av_data_type","text":"__itt_av_data_type\n\n__itt_av_data_type\n\nDefines types of arrays data (for C/C++ intrinsic types)\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_collection_scope","page":"Home","title":"LibAwsCommon.__itt_collection_scope","text":"__itt_collection_scope\n\n__itt_collection_scope\n\nEnumerator for collection scopes\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_collection_state","page":"Home","title":"LibAwsCommon.__itt_collection_state","text":"__itt_collection_state\n\n__itt_collection_state\n\nEnumerator for collection state.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_context_type","page":"Home","title":"LibAwsCommon.__itt_context_type","text":"__itt_context_type\n\ndescribes the type of context metadata\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_metadata_type","page":"Home","title":"LibAwsCommon.__itt_metadata_type","text":"__itt_metadata_type\n\nparameters\n\ndescribes the type of metadata\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_model_disable","page":"Home","title":"LibAwsCommon.__itt_model_disable","text":"__itt_model_disable\n\n__itt_model_disable\n\nEnumerator for the disable methods\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_module_type","page":"Home","title":"LibAwsCommon.__itt_module_type","text":"__itt_module_type\n\nexclude_from_documentation\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_relation","page":"Home","title":"LibAwsCommon.__itt_relation","text":"__itt_relation\n\nrelations\n\nThe kind of relation between two instances is specified by the enumerated type __itt_relation. Relations between instances can be added with an API call. The relation API uses instance IDs. Relations can be added before or after the actual instances are created and persist independently of the instances. This is the motivation for having different lifetimes for instance IDs and the actual instances.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_scope","page":"Home","title":"LibAwsCommon.__itt_scope","text":"__itt_scope\n\nDescribes the scope of an event object in the trace.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_section_type","page":"Home","title":"LibAwsCommon.__itt_section_type","text":"__itt_section_type\n\nexclude_from_documentation\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__itt_suppress_mode","page":"Home","title":"LibAwsCommon.__itt_suppress_mode","text":"__itt_suppress_mode\n\n__itt_suppress_mode\n\nEnumerator for the suppressing modes\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__pid_t","page":"Home","title":"LibAwsCommon.__pid_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__pthread_internal_list","page":"Home","title":"LibAwsCommon.__pthread_internal_list","text":"__pthread_internal_list\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__pthread_list_t","page":"Home","title":"LibAwsCommon.__pthread_list_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__pthread_mutex_s","page":"Home","title":"LibAwsCommon.__pthread_mutex_s","text":"__pthread_mutex_s\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__time_t","page":"Home","title":"LibAwsCommon.__time_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.__uid_t","page":"Home","title":"LibAwsCommon.__uid_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_allocator","page":"Home","title":"LibAwsCommon.aws_allocator","text":"aws_allocator\n\nAllocator structure. An instance of this will be passed around for anything needing memory allocation\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_array_list","page":"Home","title":"LibAwsCommon.aws_array_list","text":"aws_array_list\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_array_list_comparator_fn","page":"Home","title":"LibAwsCommon.aws_array_list_comparator_fn","text":"Prototype for a comparator function for sorting elements.\n\na and b should be cast to pointers to the element type held in the list before being dereferenced. The function should compare the elements and return a positive number if a > b, zero if a = b, and a negative number if a < b.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_atomic_impl_int_t","page":"Home","title":"LibAwsCommon.aws_atomic_impl_int_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_atomic_var","page":"Home","title":"LibAwsCommon.aws_atomic_var","text":"aws_atomic_var\n\nstruct aws_atomic_var represents an atomic variable - a value which can hold an integer or pointer that can be manipulated atomically. struct aws_atomic_vars should normally only be manipulated with atomics methods defined in this header.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_byte_buf","page":"Home","title":"LibAwsCommon.aws_byte_buf","text":"aws_byte_buf\n\nRepresents a length-delimited binary string or buffer. If byte buffer points to constant memory or memory that should otherwise not be freed by this struct, set allocator to NULL and free function will be a no-op.\n\nThis structure used to define the output for all functions that write to a buffer.\n\nNote that this structure allocates memory at the buffer pointer only. The struct itself does not get dynamically allocated and must be either maintained or copied to avoid losing access to the memory.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_byte_cursor","page":"Home","title":"LibAwsCommon.aws_byte_cursor","text":"aws_byte_cursor\n\nRepresents a movable pointer within a larger binary string or buffer.\n\nThis structure is used to define buffers for reading.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_byte_predicate_fn","page":"Home","title":"LibAwsCommon.aws_byte_predicate_fn","text":"Signature for function argument to trim APIs\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cache","page":"Home","title":"LibAwsCommon.aws_cache","text":"aws_cache\n\nBase stucture for caches, used the linked hash table implementation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cache_vtable","page":"Home","title":"LibAwsCommon.aws_cache_vtable","text":"aws_cache_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cbor_decoder","page":"Home","title":"LibAwsCommon.aws_cbor_decoder","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cbor_encoder","page":"Home","title":"LibAwsCommon.aws_cbor_encoder","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cbor_type","page":"Home","title":"LibAwsCommon.aws_cbor_type","text":"aws_cbor_type\n\nThe types use by APIs, not 1:1 with major type. It's an extension for cbor major type in RFC8949 section 3.1 Major type 0 - AWS_CBOR_TYPE_UINT Major type 1 - AWS_CBOR_TYPE_NEGINT Major type 2 - AWS_CBOR_TYPE_BYTES/AWS_CBOR_TYPE_INDEF_BYTES_START Major type 3 - AWS_CBOR_TYPE_TEXT/AWS_CBOR_TYPE_INDEF_TEXT_START Major type 4 - AWS_CBOR_TYPE_ARRAY_START/AWS_CBOR_TYPE_INDEF_ARRAY_START Major type 5 - AWS_CBOR_TYPE_MAP_START/AWS_CBOR_TYPE_INDEF_MAP_START Major type 6 - AWS_CBOR_TYPE_TAG Major type 7 - 20/21 - AWS_CBOR_TYPE_BOOL - 22 - AWS_CBOR_TYPE_NULL - 23 - AWS_CBOR_TYPE_UNDEFINED - 25/26/27 - AWS_CBOR_TYPE_FLOAT - 31 - AWS_CBOR_TYPE_BREAK - rest of value are not supported.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cli_option","page":"Home","title":"LibAwsCommon.aws_cli_option","text":"aws_cli_option\n\nIgnoring padding since we're trying to maintain getopt.h compatibility\n\nNOLINTNEXTLINE(clang-analyzer-optin.performance.Padding)\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cli_options_has_arg","page":"Home","title":"LibAwsCommon.aws_cli_options_has_arg","text":"aws_cli_options_has_arg\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cli_options_subcommand_fn","page":"Home","title":"LibAwsCommon.aws_cli_options_subcommand_fn","text":"Invoked when a subcommand is encountered. argc and argv[] begins at the command encountered. command_name is the name of the command being handled.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cli_subcommand_dispatch","page":"Home","title":"LibAwsCommon.aws_cli_subcommand_dispatch","text":"aws_cli_subcommand_dispatch\n\nDispatch table to dispatch cli commands from. command_name should be the exact string for the command you want to handle from the command line.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_common_error","page":"Home","title":"LibAwsCommon.aws_common_error","text":"aws_common_error\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_common_log_subject","page":"Home","title":"LibAwsCommon.aws_common_log_subject","text":"aws_common_log_subject\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_condition_predicate_fn","page":"Home","title":"LibAwsCommon.aws_condition_predicate_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_condition_variable","page":"Home","title":"LibAwsCommon.aws_condition_variable","text":"aws_condition_variable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cpu_feature_name","page":"Home","title":"LibAwsCommon.aws_cpu_feature_name","text":"aws_cpu_feature_name\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cpu_info","page":"Home","title":"LibAwsCommon.aws_cpu_info","text":"aws_cpu_info\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_cross_process_lock","page":"Home","title":"LibAwsCommon.aws_cross_process_lock","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_common_statistics_category","page":"Home","title":"LibAwsCommon.aws_crt_common_statistics_category","text":"aws_crt_common_statistics_category\n\nThe common-specific range of the aws_crt_statistics_category cross-library enum.\n\nThis enum functions as an RTTI value that lets statistics handler's interpret (via cast) a specific statistics structure if the RTTI value is understood.\n\nCommon doesn't have any statistics structures presently, so its range is essentially empty.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_base","page":"Home","title":"LibAwsCommon.aws_crt_statistics_base","text":"aws_crt_statistics_base\n\nPattern-struct that functions as a base \"class\" for all statistics structures. To conform to the pattern, a statistics structure must have its first member be the category. In that case it becomes \"safe\" to cast from aws_crt_statistics_base to the specific statistics structure based on the category value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_category_t","page":"Home","title":"LibAwsCommon.aws_crt_statistics_category_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_handler","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler","text":"aws_crt_statistics_handler\n\nBase structure for all statistics handler implementations.\n\nA statistics handler is an object that listens to a stream of polymorphic (via the category RTTI enum) statistics structures emitted from some arbitrary source. In the initial implementation, statistics handlers are primarily attached to channels, where they monitor IO throughput and state data (from channel handlers) to determine a connection's health.\n\nStatistics handlers are a generalization of the timeout and bandwidth filters that are often associated with SDK network connections. Configurable, default implementations are defined at the protocol level (http, etc...) where they can be attached at connection (channel) creation time.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_handler_destroy_fn","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler_destroy_fn","text":"Destroys a statistics handler implementation\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_handler_get_report_interval_ms_fn","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler_get_report_interval_ms_fn","text":"The period, in milliseconds, that the handler would like to be informed of statistics. Statistics generators are not required to honor this value, but should if able.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_handler_process_statistics_fn","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler_process_statistics_fn","text":"Statistics intake function. The array_list is a list of pointers to aws_crt_statistics_base \"derived\" (via pattern) objects. The handler should iterate the list and downcast elements whose RTTI category it understands, while skipping those it does not understand.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_handler_vtable","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler_vtable","text":"aws_crt_statistics_handler_vtable\n\nVtable for functions that all statistics handlers must implement\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_crt_statistics_sample_interval","page":"Home","title":"LibAwsCommon.aws_crt_statistics_sample_interval","text":"aws_crt_statistics_sample_interval\n\nThe start and end time, in milliseconds-since-epoch, that a set of statistics was gathered over.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_date_day_of_week","page":"Home","title":"LibAwsCommon.aws_date_day_of_week","text":"aws_date_day_of_week\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_date_format","page":"Home","title":"LibAwsCommon.aws_date_format","text":"aws_date_format\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_date_month","page":"Home","title":"LibAwsCommon.aws_date_month","text":"aws_date_month\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_date_time","page":"Home","title":"LibAwsCommon.aws_date_time","text":"aws_date_time\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_directory_entry","page":"Home","title":"LibAwsCommon.aws_directory_entry","text":"aws_directory_entry\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_directory_iterator","page":"Home","title":"LibAwsCommon.aws_directory_iterator","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_error_handler_fn","page":"Home","title":"LibAwsCommon.aws_error_handler_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_error_info","page":"Home","title":"LibAwsCommon.aws_error_info","text":"aws_error_info\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_error_info_list","page":"Home","title":"LibAwsCommon.aws_error_info_list","text":"aws_error_info_list\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_file_type","page":"Home","title":"LibAwsCommon.aws_file_type","text":"aws_file_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_hash_callback_destroy_fn","page":"Home","title":"LibAwsCommon.aws_hash_callback_destroy_fn","text":"Prototype for a hash table key or value destructor function pointer.\n\nThis function is used to destroy elements in the hash table when the table is cleared or cleaned up.\n\nNote that functions which remove individual elements from the hash table provide options of whether or not to invoke the destructors on the key and value of a removed element.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_hash_callback_eq_fn","page":"Home","title":"LibAwsCommon.aws_hash_callback_eq_fn","text":"Prototype for a hash table equality check function pointer.\n\nThis type is usually used for a function that compares two hash table keys, but note that the same type is used for a function that compares two hash table values in aws_hash_table_eq.\n\nEquality functions used in a hash table must be be reflexive (a == a), symmetric (a == b => b == a), transitive (a == b, b == c => a == c) and consistent (result does not change with time).\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_hash_element","page":"Home","title":"LibAwsCommon.aws_hash_element","text":"aws_hash_element\n\nRepresents an element in the hash table. Various operations on the hash table may provide pointers to elements stored within the hash table; generally, calling code may alter value, but must not alter key (or any information used to compute key's hash code).\n\nPointers to elements within the hash are invalidated whenever an operation which may change the number of elements in the hash is invoked (i.e. put, delete, clear, and clean_up), regardless of whether the number of elements actually changes.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_hash_fn","page":"Home","title":"LibAwsCommon.aws_hash_fn","text":"Prototype for a key hashing function pointer.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_hash_iter","page":"Home","title":"LibAwsCommon.aws_hash_iter","text":"aws_hash_iter\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_hash_iter_status","page":"Home","title":"LibAwsCommon.aws_hash_iter_status","text":"aws_hash_iter_status\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_hash_table","page":"Home","title":"LibAwsCommon.aws_hash_table","text":"aws_hash_table\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_json_on_member_encountered_const_fn","page":"Home","title":"LibAwsCommon.aws_json_on_member_encountered_const_fn","text":"callback for iterating members of an object Iteration can be controlled as follows: - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) - continue iteration without error - return AWS_OP_SUCCESS and out_continue is set to false - stop iteration without error - return AWS_OP_ERR - stop iteration with error\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_json_on_value_encountered_const_fn","page":"Home","title":"LibAwsCommon.aws_json_on_value_encountered_const_fn","text":"callback for iterating values of an array. Iteration can be controlled as follows: - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) - continue iteration without error - return AWS_OP_SUCCESS and out_continue is set to false - stop iteration without error - return AWS_OP_ERR - stop iteration with error\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_json_value","page":"Home","title":"LibAwsCommon.aws_json_value","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_linked_hash_table","page":"Home","title":"LibAwsCommon.aws_linked_hash_table","text":"aws_linked_hash_table\n\nSimple linked hash table. Preserves insertion order, and can be iterated in insertion order.\n\nYou can also change the order safely without altering the shape of the underlying hash table.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_linked_hash_table_node","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_node","text":"aws_linked_hash_table_node\n\nLinked-List node stored in the table. This is the node type that will be returned in aws_linked_hash_table_get_iteration_list().\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_linked_list","page":"Home","title":"LibAwsCommon.aws_linked_list","text":"aws_linked_list\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_linked_list_node","page":"Home","title":"LibAwsCommon.aws_linked_list_node","text":"aws_linked_list_node\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_channel","page":"Home","title":"LibAwsCommon.aws_log_channel","text":"aws_log_channel\n\nLog channel interface and default implementations\n\nA log channel is an abstraction for the transfer of formatted log data between a source (formatter) and a sink (writer).\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_channel_clean_up_fn","page":"Home","title":"LibAwsCommon.aws_log_channel_clean_up_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_channel_send_fn","page":"Home","title":"LibAwsCommon.aws_log_channel_send_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_channel_vtable","page":"Home","title":"LibAwsCommon.aws_log_channel_vtable","text":"aws_log_channel_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_formatter","page":"Home","title":"LibAwsCommon.aws_log_formatter","text":"aws_log_formatter\n\nLog formatter interface and default implementation\n\nLog formatters are invoked by the LOGF_* macros to transform a set of arguments into one or more lines of text to be output to a logging sink (writer).\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_formatter_clean_up_fn","page":"Home","title":"LibAwsCommon.aws_log_formatter_clean_up_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_formatter_format_fn","page":"Home","title":"LibAwsCommon.aws_log_formatter_format_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_formatter_standard_options","page":"Home","title":"LibAwsCommon.aws_log_formatter_standard_options","text":"aws_log_formatter_standard_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_formatter_vtable","page":"Home","title":"LibAwsCommon.aws_log_formatter_vtable","text":"aws_log_formatter_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_level","page":"Home","title":"LibAwsCommon.aws_log_level","text":"aws_log_level\n\nControls what log calls pass through the logger and what log calls get filtered out. If a log level has a value of X, then all log calls using a level <= X will appear, while those using a value > X will not occur.\n\nYou can filter both dynamically (by setting the log level on the logger object) or statically (by defining AWS_STATIC_LOG_LEVEL to be an appropriate integer module-wide). Statically filtered log calls will be completely compiled out but require a rebuild if you want to get more detail about what's happening.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_subject_info","page":"Home","title":"LibAwsCommon.aws_log_subject_info","text":"aws_log_subject_info\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_subject_info_list","page":"Home","title":"LibAwsCommon.aws_log_subject_info_list","text":"aws_log_subject_info_list\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_subject_t","page":"Home","title":"LibAwsCommon.aws_log_subject_t","text":"Log subject is a way of designating the topic of logging.\n\nThe general idea is to support a finer-grained approach to log level control. The primary use case is for situations that require more detailed logging within a specific domain, where enabling that detail globally leads to an untenable flood of information.\n\nFor example, enable TRACE logging for tls-related log statements (handshake binary payloads), but only WARN logging everywhere else (because http payloads would blow up the log files).\n\nLog subject is an enum similar to aws error: each library has its own value-space and someone is responsible for registering the value <-> string connections.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_writer","page":"Home","title":"LibAwsCommon.aws_log_writer","text":"aws_log_writer\n\nLog writer interface and default implementation(s)\n\nA log writer functions as a sink for formatted log lines. We provide default implementations that go to stdout, stderr, and a specified file.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_writer_clean_up_fn","page":"Home","title":"LibAwsCommon.aws_log_writer_clean_up_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_writer_file_options","page":"Home","title":"LibAwsCommon.aws_log_writer_file_options","text":"aws_log_writer_file_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_writer_vtable","page":"Home","title":"LibAwsCommon.aws_log_writer_vtable","text":"aws_log_writer_vtable\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_log_writer_write_fn","page":"Home","title":"LibAwsCommon.aws_log_writer_write_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_logger","page":"Home","title":"LibAwsCommon.aws_logger","text":"aws_logger\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_logger_pipeline","page":"Home","title":"LibAwsCommon.aws_logger_pipeline","text":"aws_logger_pipeline\n\nStandard logger implementation composing three sub-components:\n\nThe formatter takes var args input from the user and produces a formatted log line The writer takes a formatted log line and outputs it somewhere The channel is the transport between the two\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_logger_standard_options","page":"Home","title":"LibAwsCommon.aws_logger_standard_options","text":"aws_logger_standard_options\n\nOptions for aws_logger_init_standard(). Set filename to open a file for logging and close it when the logger cleans up. Set file to use a file that is already open, such as stderr or stdout.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_logger_vtable","page":"Home","title":"LibAwsCommon.aws_logger_vtable","text":"aws_logger_vtable\n\nWe separate the log level function from the log call itself so that we can do the filter check in the macros (see below)\n\nBy doing so, we make it so that the variadic format arguments are not even evaluated if the filter check does not succeed.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_logging_standard_formatting_data","page":"Home","title":"LibAwsCommon.aws_logging_standard_formatting_data","text":"aws_logging_standard_formatting_data\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_mem_trace_level","page":"Home","title":"LibAwsCommon.aws_mem_trace_level","text":"aws_mem_trace_level\n\nMaintainer note: The above function doesn't return the pointer (as with standard C realloc) as this pattern becomes error-prone when OOMs occur. In particular, we want to avoid losing the old pointer when an OOM condition occurs, so we prefer to take the old pointer as an in/out reference argument that we can leave unchanged on failure.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_memory_order","page":"Home","title":"LibAwsCommon.aws_memory_order","text":"aws_memory_order\n\nThis enumeration specifies the memory ordering properties requested for a particular atomic operation. The atomic operation may provide stricter ordering than requested. Note that, within a single thread, all operations are still sequenced (that is, a thread sees its own atomic writes and reads happening in program order, but other threads may disagree on this ordering).\n\nThe behavior of these memory orderings are the same as in the C11 atomics API; however, we only implement a subset that can be portably implemented on the compilers we target.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_memory_usage_stats","page":"Home","title":"LibAwsCommon.aws_memory_usage_stats","text":"aws_memory_usage_stats\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_mutex","page":"Home","title":"LibAwsCommon.aws_mutex","text":"aws_mutex\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_off_t","page":"Home","title":"LibAwsCommon.aws_off_t","text":"compat: Deprecated\nUse int64_t instead for offsets in public APIs.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_on_directory_entry","page":"Home","title":"LibAwsCommon.aws_on_directory_entry","text":"Invoked during calls to aws_directory_traverse() as an entry is encountered. entry will contain the parsed directory entry info.\n\nReturn true to continue the traversal, or alternatively, if you have a reason to abort the traversal, return false.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_platform_os","page":"Home","title":"LibAwsCommon.aws_platform_os","text":"aws_platform_os\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_priority_queue","page":"Home","title":"LibAwsCommon.aws_priority_queue","text":"aws_priority_queue\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_priority_queue_compare_fn","page":"Home","title":"LibAwsCommon.aws_priority_queue_compare_fn","text":"The comparator should return a positive value if the second argument has a higher priority than the first; Otherwise, it should return a negative value or zero. NOTE: priority_queue pops its highest priority element first. For example: int cmp(const void *a, const void *b) { return a < b; } would result in a max heap, while: int cmp(const void *a, const void *b) { return a > b; } would result in a min heap.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_priority_queue_node","page":"Home","title":"LibAwsCommon.aws_priority_queue_node","text":"aws_priority_queue_node\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_ref_count","page":"Home","title":"LibAwsCommon.aws_ref_count","text":"aws_ref_count\n\nA utility type for making ref-counted types, reminiscent of std::shared_ptr in C++\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_ring_buffer","page":"Home","title":"LibAwsCommon.aws_ring_buffer","text":"aws_ring_buffer\n\nLockless ring buffer implementation that is thread safe assuming a single thread acquires and a single thread releases. For any other use case (other than the single-threaded use-case), you must manage thread-safety manually.\n\nAlso, a very important note: release must happen in the same order as acquire. If you do not your application, and possibly computers within a thousand mile radius, may die terrible deaths, and the local drinking water will be poisoned for generations with fragments of what is left of your radioactive corrupted memory.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_run_command_options","page":"Home","title":"LibAwsCommon.aws_run_command_options","text":"aws_run_command_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_run_command_result","page":"Home","title":"LibAwsCommon.aws_run_command_result","text":"aws_run_command_result\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_rw_lock","page":"Home","title":"LibAwsCommon.aws_rw_lock","text":"aws_rw_lock\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_shutdown_callback_options","page":"Home","title":"LibAwsCommon.aws_shutdown_callback_options","text":"aws_shutdown_callback_options\n\nConfiguration for a callback to invoke when something has been completely cleaned up. Primarily used in async cleanup control flows.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_simple_completion_callback","page":"Home","title":"LibAwsCommon.aws_simple_completion_callback","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_string","page":"Home","title":"LibAwsCommon.aws_string","text":"aws_string\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_system_environment","page":"Home","title":"LibAwsCommon.aws_system_environment","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_task","page":"Home","title":"LibAwsCommon.aws_task","text":"aws_task\n\nA task object. Once added to the scheduler, a task must remain in memory until its function is executed.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_task_fn","page":"Home","title":"LibAwsCommon.aws_task_fn","text":"A scheduled function.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_task_scheduler","page":"Home","title":"LibAwsCommon.aws_task_scheduler","text":"aws_task_scheduler\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_task_status","page":"Home","title":"LibAwsCommon.aws_task_status","text":"aws_task_status\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_test_after_fn","page":"Home","title":"LibAwsCommon.aws_test_after_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_test_before_fn","page":"Home","title":"LibAwsCommon.aws_test_before_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_test_harness","page":"Home","title":"LibAwsCommon.aws_test_harness","text":"aws_test_harness\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_test_run_fn","page":"Home","title":"LibAwsCommon.aws_test_run_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_text_encoding","page":"Home","title":"LibAwsCommon.aws_text_encoding","text":"aws_text_encoding\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread","page":"Home","title":"LibAwsCommon.aws_thread","text":"aws_thread\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread_atexit_fn","page":"Home","title":"LibAwsCommon.aws_thread_atexit_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread_detach_state","page":"Home","title":"LibAwsCommon.aws_thread_detach_state","text":"aws_thread_detach_state\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread_id_t","page":"Home","title":"LibAwsCommon.aws_thread_id_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread_join_strategy","page":"Home","title":"LibAwsCommon.aws_thread_join_strategy","text":"aws_thread_join_strategy\n\nSpecifies the join strategy used on an aws_thread, which in turn controls whether or not a thread participates in the managed thread system. The managed thread system provides logic to guarantee a join on all participating threads at the cost of laziness (the user cannot control when joins happen).\n\nManual - thread does not participate in the managed thread system; any joins must be done by the user. This is the default. The user must call aws_thread_clean_up(), but only after any desired join operation has completed. Not doing so will cause the windows handle to leak.\n\nManaged - the managed thread system will automatically perform a join some time after the thread's run function has completed. It is an error to call aws_thread_join on a thread configured with the managed join strategy. The managed thread system will call aws_thread_clean_up() on the thread after the background join has completed.\n\nAdditionally, an API exists, aws_thread_join_all_managed(), which blocks and returns when all outstanding threads with the managed strategy have fully joined. This API is useful for tests (rather than waiting for many individual signals) and program shutdown or DLL unload. This API is automatically invoked by the common library clean up function. If the common library clean up is called from a managed thread, this will cause deadlock.\n\nLazy thread joining is done only when threads finish their run function or when the user calls aws_thread_join_all_managed(). This means it may be a long time between thread function completion and the join being applied, but the queue of unjoined threads is always one or fewer so there is no critical resource backlog.\n\nCurrently, only event loop group async cleanup and host resolver threads participate in the managed thread system. Additionally, event loop threads will increment and decrement the pending join count (they are manually joined internally) in order to have an accurate view of internal thread usage and also to prevent failure to release an event loop group fully from allowing aws_thread_join_all_managed() from running to completion when its intent is such that it should block instead.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread_once","page":"Home","title":"LibAwsCommon.aws_thread_once","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread_options","page":"Home","title":"LibAwsCommon.aws_thread_options","text":"aws_thread_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_thread_scheduler","page":"Home","title":"LibAwsCommon.aws_thread_scheduler","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_timestamp_unit","page":"Home","title":"LibAwsCommon.aws_timestamp_unit","text":"aws_timestamp_unit\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_uri","page":"Home","title":"LibAwsCommon.aws_uri","text":"aws_uri\n\nData representing a URI. uri_str is always allocated and filled in. The other portions are merely storing offsets into uri_str.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_uri_builder_options","page":"Home","title":"LibAwsCommon.aws_uri_builder_options","text":"aws_uri_builder_options\n\nArguments for building a URI instance. All members must be initialized before passing them to aws_uri_init().\n\nquery_string and query_params are exclusive to each other. If you set query_string, do not prepend it with '?'\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_uri_param","page":"Home","title":"LibAwsCommon.aws_uri_param","text":"aws_uri_param\n\nkey/value pairs for a query string. If the query fragment was not in format key=value, the fragment value will be stored in key\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_utf8_decoder","page":"Home","title":"LibAwsCommon.aws_utf8_decoder","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_utf8_decoder_options","page":"Home","title":"LibAwsCommon.aws_utf8_decoder_options","text":"aws_utf8_decoder_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_uuid","page":"Home","title":"LibAwsCommon.aws_uuid","text":"aws_uuid\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_xml_attribute","page":"Home","title":"LibAwsCommon.aws_xml_attribute","text":"aws_xml_attribute\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_xml_node","page":"Home","title":"LibAwsCommon.aws_xml_node","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_xml_parser_on_node_encountered_fn","page":"Home","title":"LibAwsCommon.aws_xml_parser_on_node_encountered_fn","text":"Callback for when an xml node is encountered in the document. As a user you have a few options:\n\nfail the parse by returning AWS_OP_ERR (after an error has been raised). This will stop any further parsing. 2. call aws_xml_node_traverse() on the node to descend into the node with a new callback and user_data. 3. call aws_xml_node_as_body() to retrieve the contents of the node as text.\n\nYou MUST NOT call both aws_xml_node_traverse() and aws_xml_node_as_body() on the same node.\n\nreturn true to continue the parsing operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_xml_parser_options","page":"Home","title":"LibAwsCommon.aws_xml_parser_options","text":"aws_xml_parser_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.hash_table_state","page":"Home","title":"LibAwsCommon.hash_table_state","text":"Hash table data structure. This module provides an automatically resizing hash table implementation for general purpose use. The hash table stores a mapping between void * keys and values; it is expected that in most cases, these will point to a structure elsewhere in the heap, instead of inlining a key or value into the hash table element itself.\n\nCurrently, this hash table implements a variant of robin hood hashing, but we do not guarantee that this won't change in the future.\n\nAssociated with each hash function are four callbacks:\n\nhash_fn - A hash function from the keys to a uint64_t. It is critical that the hash function for a key does not change while the key is in the hash table; violating this results in undefined behavior. Collisions are tolerated, though naturally with reduced performance.\n\nequals_fn - An equality comparison function. This function must be reflexive and consistent with hash_fn.\n\ndestroy_key_fn, destroy_value_fn - Optional callbacks invoked when the table is cleared or cleaned up and at the caller's option when an element is removed from the table. Either or both may be set to NULL, which has the same effect as a no-op destroy function.\n\nThis datastructure can be safely moved between threads, subject to the requirements of the underlying allocator. It is also safe to invoke non-mutating operations on the hash table from multiple threads. A suitable memory barrier must be used when transitioning from single-threaded mutating usage to multithreaded usage.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.pthread_cond_t","page":"Home","title":"LibAwsCommon.pthread_cond_t","text":"pthread_cond_t\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.pthread_mutex_t","page":"Home","title":"LibAwsCommon.pthread_mutex_t","text":"pthread_mutex_t\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.pthread_once_t","page":"Home","title":"LibAwsCommon.pthread_once_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.pthread_rwlock_t","page":"Home","title":"LibAwsCommon.pthread_rwlock_t","text":"pthread_rwlock_t\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.pthread_t","page":"Home","title":"LibAwsCommon.pthread_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.siginfo","page":"Home","title":"LibAwsCommon.siginfo","text":"siginfo\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.siginfo_t","page":"Home","title":"LibAwsCommon.siginfo_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.sigval","page":"Home","title":"LibAwsCommon.sigval","text":"sigval\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.sigval_t","page":"Home","title":"LibAwsCommon.sigval_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.static_assertion_at_line_60","page":"Home","title":"LibAwsCommon.static_assertion_at_line_60","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.static_assertion_at_line_61","page":"Home","title":"LibAwsCommon.static_assertion_at_line_61","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.static_assertion_at_line_62","page":"Home","title":"LibAwsCommon.static_assertion_at_line_62","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/pthreadtypes.h:117:3)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/pthreadtypes.h:117:3)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/pthreadtypes.h:117:3)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/pthreadtypes.h:153:3)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/pthreadtypes.h:153:3)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/pthreadtypes.h:153:3)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:102:2)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:102:2)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:102:2)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:63:2)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:63:2)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:63:2)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:70:2)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:70:2)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:70:2)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:78:2)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:78:2)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:78:2)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:86:2)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:86:2)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:86:2)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:96:2)","page":"Home","title":"LibAwsCommon.struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:96:2)","text":"var\"struct (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:96:2)\"\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.time_t","page":"Home","title":"LibAwsCommon.time_t","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.tm","page":"Home","title":"LibAwsCommon.tm","text":"tm\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.union (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:58:5)","page":"Home","title":"LibAwsCommon.union (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:58:5)","text":"union (unnamed at /home/runner/.julia/artifacts/305c8b171016c46dfbb8ca234a543a99b6e3d045/x86_64-linux-gnu/sys-root/usr/include/bits/siginfo.h:58:5)\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.union (unnamed at /home/runner/.julia/artifacts/d3c04159ad974d3059b28cf352c4225572527bf2/include/aws/common/task_scheduler.h:40:5)","page":"Home","title":"LibAwsCommon.union (unnamed at /home/runner/.julia/artifacts/d3c04159ad974d3059b28cf352c4225572527bf2/include/aws/common/task_scheduler.h:40:5)","text":"union (unnamed at /home/runner/.julia/artifacts/d3c04159ad974d3059b28cf352c4225572527bf2/include/aws/common/task_scheduler.h:40:5)\n\nhonor the ABI compat\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsCommon.aws_add_size_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_add_size_checked","text":"aws_add_size_checked(a, b, r)\n\nAdds a + b and returns the result in *r. If the result overflows, returns AWS_OP_ERR; otherwise returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_add_size_checked(size_t a, size_t b, size_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_add_size_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_add_size_saturating","text":"aws_add_size_saturating(a, b)\n\nAdds a + b. If the result overflows returns SIZE_MAX.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_add_size_saturating(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_add_u32_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_add_u32_checked","text":"aws_add_u32_checked(a, b, r)\n\nIf a + b overflows, returns AWS_OP_ERR; otherwise adds a + b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_add_u32_checked(uint32_t a, uint32_t b, uint32_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_add_u32_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_add_u32_saturating","text":"aws_add_u32_saturating(a, b)\n\nAdds a + b. If the result overflows, returns 2^32 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_add_u32_saturating(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_add_u64_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_add_u64_checked","text":"aws_add_u64_checked(a, b, r)\n\nIf a + b overflows, returns AWS_OP_ERR; otherwise adds a + b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_add_u64_checked(uint64_t a, uint64_t b, uint64_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_add_u64_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_add_u64_saturating","text":"aws_add_u64_saturating(a, b)\n\nAdds a + b. If the result overflows, returns 2^64 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_add_u64_saturating(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_aligned_allocator-Tuple{}","page":"Home","title":"LibAwsCommon.aws_aligned_allocator","text":"aws_aligned_allocator()\n\nAllocator that align small allocations on 8 byte boundary and big allocations on 32/64 byte boundary.\n\nPrototype\n\nstruct aws_allocator *aws_aligned_allocator(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_allocator_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_allocator_is_valid","text":"aws_allocator_is_valid(alloc)\n\nInexpensive (constant time) check of data-structure invariants.\n\nPrototype\n\nbool aws_allocator_is_valid(const struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_eq-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_array_eq","text":"aws_array_eq(array_a, len_a, array_b, len_b)\n\nCompare two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0.\n\nPrototype\n\nbool aws_array_eq(const void *const array_a, const size_t len_a, const void *array_b, const size_t len_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_eq_c_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_eq_c_str","text":"aws_array_eq_c_str(array, array_len, c_str)\n\nCompare an array and a null-terminated string. Returns true if their contents are equivalent. The array should NOT contain a null-terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0.\n\nPrototype\n\nbool aws_array_eq_c_str(const void *const array, const size_t array_len, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_eq_c_str_ignore_case-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_eq_c_str_ignore_case","text":"aws_array_eq_c_str_ignore_case(array, array_len, c_str)\n\nPerform a case-insensitive string comparison of an array and a null-terminated string. Return whether their contents are equivalent. The array should NOT contain a null-terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_array_eq_c_str_ignore_case(const void *const array, const size_t array_len, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_eq_ignore_case-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_array_eq_ignore_case","text":"aws_array_eq_ignore_case(array_a, len_a, array_b, len_b)\n\nPerform a case-insensitive string comparison of two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_array_eq_ignore_case( const void *const array_a, const size_t len_a, const void *const array_b, const size_t len_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_back-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_back","text":"aws_array_list_back(list, val)\n\nCopies the element at the end of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_back(const struct aws_array_list *AWS_RESTRICT list, void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_capacity-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_capacity","text":"aws_array_list_capacity(list)\n\nReturns the number of elements that can fit in the internal array. If list is initialized in dynamic mode, the capacity changes over time.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_array_list_capacity(const struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_clean_up","text":"aws_array_list_clean_up(list)\n\nDeallocates any memory that was allocated for this list, and resets list for reuse or deletion.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_clean_up(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_clean_up_secure-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_clean_up_secure","text":"aws_array_list_clean_up_secure(list)\n\nErases and then deallocates any memory that was allocated for this list, and resets list for reuse or deletion.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_clean_up_secure(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_clear-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_clear","text":"aws_array_list_clear(list)\n\nClears all elements in the array and resets length to zero. Size does not change in this operation.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_clear(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_comparator_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_comparator_string","text":"aws_array_list_comparator_string(a, b)\n\nA convenience function for sorting lists of (const struct aws_string *) elements. This can be used as a comparator for aws_array_list_sort. It is just a simple wrapper around aws_string_compare.\n\nPrototype\n\nint aws_array_list_comparator_string(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_copy-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_copy","text":"aws_array_list_copy(from, to)\n\nCopies the elements from from to to. If to is in static mode, it must at least be the same length as from. Any data in to will be overwritten in this copy.\n\nPrototype\n\nint aws_array_list_copy(const struct aws_array_list *AWS_RESTRICT from, struct aws_array_list *AWS_RESTRICT to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_ensure_capacity-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_ensure_capacity","text":"aws_array_list_ensure_capacity(list, index)\n\nEnsures that the array list has enough capacity to store a value at the specified index. If there is not already enough capacity, and the list is in dynamic mode, this function will attempt to allocate more memory, expanding the list. In static mode, if 'index' is beyond the maximum index, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nint aws_array_list_ensure_capacity(struct aws_array_list *AWS_RESTRICT list, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_erase-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_erase","text":"aws_array_list_erase(list, index)\n\nDeletes the element this index in the list if it exists. If element does not exist, AWS_ERROR_INVALID_INDEX will be raised. This call results in shifting all remaining elements towards the front. Avoid this call unless that is intended behavior.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_erase(struct aws_array_list *AWS_RESTRICT list, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_front-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_front","text":"aws_array_list_front(list, val)\n\nCopies the element at the front of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_front(const struct aws_array_list *AWS_RESTRICT list, void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_get_at-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_get_at","text":"aws_array_list_get_at(list, val, index)\n\nCopies the memory at index to val. If element does not exist, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_get_at(const struct aws_array_list *AWS_RESTRICT list, void *val, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_get_at_ptr-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_get_at_ptr","text":"aws_array_list_get_at_ptr(list, val, index)\n\nCopies the memory address of the element at index to *val. If element does not exist, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_get_at_ptr(const struct aws_array_list *AWS_RESTRICT list, void **val, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_init_dynamic-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_init_dynamic","text":"aws_array_list_init_dynamic(list, alloc, initial_item_allocation, item_size)\n\nInitializes an array list with an array of size initial_item_allocation * item_size. In this mode, the array size will grow by a factor of 2 upon insertion if space is not available. initial_item_allocation is the number of elements you want space allocated for. item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_init_dynamic( struct aws_array_list *AWS_RESTRICT list, struct aws_allocator *alloc, size_t initial_item_allocation, size_t item_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_init_static-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_init_static","text":"aws_array_list_init_static(list, raw_array, item_count, item_size)\n\nInitializes an array list with a preallocated array of void *. item_count is the number of elements in the array, and item_size is the size in bytes of each element. Mixing items types is not supported by this API. Once this list is full, new items will be rejected.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_init_static( struct aws_array_list *AWS_RESTRICT list, void *raw_array, size_t item_count, size_t item_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_init_static_from_initialized-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_init_static_from_initialized","text":"aws_array_list_init_static_from_initialized(list, raw_array, item_count, item_size)\n\nInitializes an array list with a preallocated array of already-initialized elements. item_count is the number of elements in the array, and item_size is the size in bytes of each element.\n\nOnce initialized, nothing further can be added to the list, since it will be full and cannot resize.\n\nPrimary use case is to treat an already-initialized C array as an array list.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_init_static_from_initialized( struct aws_array_list *AWS_RESTRICT list, void *raw_array, size_t item_count, size_t item_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_is_valid","text":"aws_array_list_is_valid(list)\n\nSet of properties of a valid aws_array_list.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_array_list_is_valid(const struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_length-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_length","text":"aws_array_list_length(list)\n\nReturns the number of elements in the internal array.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_array_list_length(const struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_pop_back-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_pop_back","text":"aws_array_list_pop_back(list)\n\nDeletes the element at the end of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_pop_back(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_pop_front-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_pop_front","text":"aws_array_list_pop_front(list)\n\nDeletes the element at the front of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised. This call results in shifting all of the elements at the end of the array to the front. Avoid this call unless that is intended behavior.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_pop_front(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_pop_front_n-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_pop_front_n","text":"aws_array_list_pop_front_n(list, n)\n\nDelete N elements from the front of the list. Remaining elements are shifted to the front of the list. If the list has less than N elements, the list is cleared. This call is more efficient than calling aws_array_list_pop_front() N times.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_pop_front_n(struct aws_array_list *AWS_RESTRICT list, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_push_back-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_push_back","text":"aws_array_list_push_back(list, val)\n\nPushes the memory pointed to by val onto the end of internal list\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_push_back(struct aws_array_list *AWS_RESTRICT list, const void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_push_front-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_push_front","text":"aws_array_list_push_front(list, val)\n\nPushes the memory pointed to by val onto the front of internal list. This call results in shifting all of the elements in the list. Avoid this call unless that is intended behavior.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_push_front(struct aws_array_list *AWS_RESTRICT list, const void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_set_at-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_set_at","text":"aws_array_list_set_at(list, val, index)\n\nCopies the the memory pointed to by val into the array at index. If in dynamic mode, the size will grow by a factor of two when the array is full. In static mode, AWS_ERROR_INVALID_INDEX will be raised if the index is past the bounds of the array.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_set_at(struct aws_array_list *AWS_RESTRICT list, const void *val, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_shrink_to_fit-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_array_list_shrink_to_fit","text":"aws_array_list_shrink_to_fit(list)\n\nIf in dynamic mode, shrinks the allocated array size to the minimum amount necessary to store its elements.\n\nPrototype\n\nint aws_array_list_shrink_to_fit(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_sort-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_sort","text":"aws_array_list_sort(list, compare_fn)\n\nSort elements in the list in-place according to the comparator function.\n\nPrototype\n\nvoid aws_array_list_sort(struct aws_array_list *AWS_RESTRICT list, aws_array_list_comparator_fn *compare_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_swap-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_swap","text":"aws_array_list_swap(list, a, b)\n\nSwap elements at the specified indices, which must be within the bounds of the array.\n\nPrototype\n\nvoid aws_array_list_swap(struct aws_array_list *AWS_RESTRICT list, size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_array_list_swap_contents-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_array_list_swap_contents","text":"aws_array_list_swap_contents(list_a, list_b)\n\nSwap contents between two dynamic lists. Both lists must use the same allocator.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_swap_contents( struct aws_array_list *AWS_RESTRICT list_a, struct aws_array_list *AWS_RESTRICT list_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_compare_exchange_int-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_compare_exchange_int","text":"aws_atomic_compare_exchange_int(var, expected, desired)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. Uses sequentially consistent memory ordering, regardless of success or failure. Returns true if the compare was successful and the variable updated to desired.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_int(volatile struct aws_atomic_var *var, size_t *expected, size_t desired);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_compare_exchange_int_explicit-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_compare_exchange_int_explicit","text":"aws_atomic_compare_exchange_int_explicit(var, expected, desired, order_success, order_failure)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. On success, the memory ordering used was order_success; otherwise, it was order_failure. order_failure must be no stronger than order_success, and must not be release or acq_rel. Returns true if the compare was successful and the variable updated to desired.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_int_explicit( volatile struct aws_atomic_var *var, size_t *expected, size_t desired, enum aws_memory_order order_success, enum aws_memory_order order_failure);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_compare_exchange_ptr-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_compare_exchange_ptr","text":"aws_atomic_compare_exchange_ptr(var, expected, desired)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. Uses sequentially consistent memory ordering, regardless of success or failure. Returns true if the compare was successful and the variable updated to desired.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_ptr(volatile struct aws_atomic_var *var, void **expected, void *desired);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_compare_exchange_ptr_explicit-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_compare_exchange_ptr_explicit","text":"aws_atomic_compare_exchange_ptr_explicit(var, expected, desired, order_success, order_failure)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. On success, the memory ordering used was order_success; otherwise, it was order_failure. order_failure must be no stronger than order_success, and must not be release or acq_rel. Returns true if the compare was successful and the variable updated to desired.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_ptr_explicit( volatile struct aws_atomic_var *var, void **expected, void *desired, enum aws_memory_order order_success, enum aws_memory_order order_failure);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_exchange_int-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_exchange_int","text":"aws_atomic_exchange_int(var, n)\n\nExchanges an integer with the value in an atomic_var, using sequentially consistent ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_exchange_int(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_exchange_int_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_exchange_int_explicit","text":"aws_atomic_exchange_int_explicit(var, n, memory_order)\n\nExchanges an integer with the value in an atomic_var, using the specified ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_exchange_int_explicit( volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_exchange_ptr-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_exchange_ptr","text":"aws_atomic_exchange_ptr(var, p)\n\nExchanges an integer with the value in an atomic_var, using sequentially consistent ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_exchange_ptr(volatile struct aws_atomic_var *var, void *p);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_exchange_ptr_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_exchange_ptr_explicit","text":"aws_atomic_exchange_ptr_explicit(var, p, memory_order)\n\nExchanges a pointer with the value in an atomic_var, using the specified ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_exchange_ptr_explicit( volatile struct aws_atomic_var *var, void *p, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_add-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_add","text":"aws_atomic_fetch_add(var, n)\n\nAtomically adds n to *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_add(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_add_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_add_explicit","text":"aws_atomic_fetch_add_explicit(var, n, order)\n\nAtomically adds n to *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_add_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_and-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_and","text":"aws_atomic_fetch_and(var, n)\n\nAtomically ands n into *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_and(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_and_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_and_explicit","text":"aws_atomic_fetch_and_explicit(var, n, order)\n\nAtomically ANDs n with *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_and_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_or-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_or","text":"aws_atomic_fetch_or(var, n)\n\nAtomically ors n into *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_or(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_or_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_or_explicit","text":"aws_atomic_fetch_or_explicit(var, n, order)\n\nAtomically ORs n with *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_or_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_sub-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_sub","text":"aws_atomic_fetch_sub(var, n)\n\nAtomically subtracts n from *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_sub(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_sub_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_sub_explicit","text":"aws_atomic_fetch_sub_explicit(var, n, order)\n\nAtomically subtracts n from *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_sub_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_xor-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_xor","text":"aws_atomic_fetch_xor(var, n)\n\nAtomically xors n into *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_xor(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_fetch_xor_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_fetch_xor_explicit","text":"aws_atomic_fetch_xor_explicit(var, n, order)\n\nAtomically XORs n with *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_xor_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_init_int-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_init_int","text":"aws_atomic_init_int(var, n)\n\nInitializes an atomic variable with an integer value. This operation should be done before any other operations on this atomic variable, and must be done before attempting any parallel operations.\n\nThis operation does not imply a barrier. Ensure that you use an acquire-release barrier (or stronger) when communicating the fact that initialization is complete to the other thread. Launching the thread implies a sufficiently strong barrier.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_init_int(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_init_ptr-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_init_ptr","text":"aws_atomic_init_ptr(var, p)\n\nInitializes an atomic variable with a pointer value. This operation should be done before any other operations on this atomic variable, and must be done before attempting any parallel operations.\n\nThis operation does not imply a barrier. Ensure that you use an acquire-release barrier (or stronger) when communicating the fact that initialization is complete to the other thread. Launching the thread implies a sufficiently strong barrier.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_init_ptr(volatile struct aws_atomic_var *var, void *p);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_load_int-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_atomic_load_int","text":"aws_atomic_load_int(var)\n\nReads an atomic var as an integer, using sequentially consistent ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_load_int(volatile const struct aws_atomic_var *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_load_int_explicit-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_load_int_explicit","text":"aws_atomic_load_int_explicit(var, memory_order)\n\nReads an atomic var as an integer, using the specified ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_load_int_explicit(volatile const struct aws_atomic_var *var, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_load_ptr-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_atomic_load_ptr","text":"aws_atomic_load_ptr(var)\n\nReads an atomic var as a pointer, using sequentially consistent ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_load_ptr(volatile const struct aws_atomic_var *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_load_ptr_explicit-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_load_ptr_explicit","text":"aws_atomic_load_ptr_explicit(var, memory_order)\n\nReads an atomic var as a pointer, using the specified ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_load_ptr_explicit(volatile const struct aws_atomic_var *var, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_priv_xlate_order-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_atomic_priv_xlate_order","text":"aws_atomic_priv_xlate_order(order)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int aws_atomic_priv_xlate_order(enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_store_int-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_store_int","text":"aws_atomic_store_int(var, n)\n\nStores an integer into an atomic var, using sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_int(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_store_int_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_store_int_explicit","text":"aws_atomic_store_int_explicit(var, n, memory_order)\n\nStores an integer into an atomic var, using the specified ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_int_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_store_ptr-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_store_ptr","text":"aws_atomic_store_ptr(var, p)\n\nStores a pointer into an atomic var, using sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_ptr(volatile struct aws_atomic_var *var, void *p);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_store_ptr_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_atomic_store_ptr_explicit","text":"aws_atomic_store_ptr_explicit(var, p, memory_order)\n\nStores a pointer into an atomic var, using the specified ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_ptr_explicit(volatile struct aws_atomic_var *var, void *p, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_atomic_thread_fence-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_atomic_thread_fence","text":"aws_atomic_thread_fence(order)\n\nProvides the same reordering guarantees as an atomic operation with the specified memory order, without needing to actually perform an atomic operation.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_thread_fence(enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_backtrace-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_backtrace","text":"aws_backtrace(stack_frames, num_frames)\n\nRecords a stack trace from the call site. Returns the number of stack entries/stack depth captured, or 0 if the operation is not supported on this platform\n\nPrototype\n\nsize_t aws_backtrace(void **stack_frames, size_t num_frames);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_backtrace_addr2line-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_backtrace_addr2line","text":"aws_backtrace_addr2line(stack_frames, stack_depth)\n\nConverts stack frame pointers to symbols, using all available system tools to try to produce a human readable result. This call will not be quick, as it shells out to addr2line or similar tools. On Windows, this is the same as aws_backtrace_symbols() Returns an array up to stack_depth long that needs to be free()ed. Missing frames will be NULL. Returns NULL if the platform does not support stack frame translation or an error occurs\n\nPrototype\n\nchar **aws_backtrace_addr2line(void *const *stack_frames, size_t stack_depth);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_backtrace_log-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_backtrace_log","text":"aws_backtrace_log(log_level)\n\nLog the callstack from the current stack to the currently configured aws_logger\n\nPrototype\n\nvoid aws_backtrace_log(int log_level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_backtrace_print-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_backtrace_print","text":"aws_backtrace_print(fp, call_site_data)\n\nPrint a backtrace from either the current stack, or (if provided) the current exception/signal call_site_data is siginfo_t* on POSIX, and LPEXCEPTION_POINTERS on Windows, and can be null\n\nPrototype\n\nvoid aws_backtrace_print(FILE *fp, void *call_site_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_backtrace_symbols-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_backtrace_symbols","text":"aws_backtrace_symbols(stack_frames, stack_depth)\n\nConverts stack frame pointers to symbols, if symbols are available Returns an array up to stack_depth long, that needs to be free()ed. stack_depth should be the length of frames. Returns NULL if the platform does not support stack frame translation or an error occurs\n\nPrototype\n\nchar **aws_backtrace_symbols(void *const *stack_frames, size_t stack_depth);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_base64_compute_decoded_len-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_base64_compute_decoded_len","text":"aws_base64_compute_decoded_len(to_decode, decoded_len)\n\nComputes the length necessary to store the output of aws_base64_decode call. returns -1 on failure, and 0 on success. decoded_len will be set on success.\n\nPrototype\n\nint aws_base64_compute_decoded_len(const struct aws_byte_cursor *AWS_RESTRICT to_decode, size_t *decoded_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_base64_compute_encoded_len-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_base64_compute_encoded_len","text":"aws_base64_compute_encoded_len(to_encode_len, encoded_len)\n\nComputes the length necessary to store the output of aws_base64_encode call. returns -1 on failure, and 0 on success. encoded_length will be set on success.\n\nPrototype\n\nint aws_base64_compute_encoded_len(size_t to_encode_len, size_t *encoded_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_base64_decode-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_base64_decode","text":"aws_base64_decode(to_decode, output)\n\nBase 64 decodes the contents of to_decode and stores the result in output.\n\nPrototype\n\nint aws_base64_decode(const struct aws_byte_cursor *AWS_RESTRICT to_decode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_base64_encode-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_base64_encode","text":"aws_base64_encode(to_encode, output)\n\nBase 64 encodes the contents of to_encode and stores the result in output.\n\nPrototype\n\nint aws_base64_encode(const struct aws_byte_cursor *AWS_RESTRICT to_encode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_advance-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_advance","text":"aws_byte_buf_advance(buffer, output, len)\n\nAppends a sub-buffer to the specified buffer.\n\nIf the buffer has at least len' bytes remaining (buffer->capacity - buffer->len >= len), then buffer->len is incremented by len, and an [awsbytebuf](@ref) is assigned to *output corresponding to the last len bytes of the input buffer. The [awsbytebuf`](@ref) at *output will have a null allocator, a zero initial length, and a capacity of 'len'. The function then returns true.\n\nIf there is insufficient space, then this function nulls all fields in *output and returns false.\n\nPrototype\n\nbool aws_byte_buf_advance( struct aws_byte_buf *const AWS_RESTRICT buffer, struct aws_byte_buf *const AWS_RESTRICT output, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append","text":"aws_byte_buf_append(to, from)\n\nCopies from to to. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest->len will contain the amount of data actually copied to dest.\n\nfrom and to may be the same buffer, permitting copying a buffer into itself.\n\nPrototype\n\nint aws_byte_buf_append(struct aws_byte_buf *to, const struct aws_byte_cursor *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_and_update-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_and_update","text":"aws_byte_buf_append_and_update(to, from_and_update)\n\nCopy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer. If buffer is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned.\n\nThe cursor is permitted to reference memory from earlier in the buffer.\n\nPrototype\n\nint aws_byte_buf_append_and_update(struct aws_byte_buf *to, struct aws_byte_cursor *from_and_update);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_byte_dynamic-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_byte_dynamic","text":"aws_byte_buf_append_byte_dynamic(buffer, value)\n\nCopies a single byte into to. If to is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nPrototype\n\nint aws_byte_buf_append_byte_dynamic(struct aws_byte_buf *buffer, uint8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_byte_dynamic_secure-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_byte_dynamic_secure","text":"aws_byte_buf_append_byte_dynamic_secure(buffer, value)\n\nCopies a single byte into to. If to is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nIf the buffer is grown, the old buffer will be securely cleared before getting freed.\n\nPrototype\n\nint aws_byte_buf_append_byte_dynamic_secure(struct aws_byte_buf *buffer, uint8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_decoding_uri-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_decoding_uri","text":"aws_byte_buf_append_decoding_uri(buffer, cursor)\n\nWrites the uri decoding of a UTF-8 cursor to a buffer, replacing xx escapes by their single byte equivalent. For example, reading \"a20b_c\" would write \"a b_c\".\n\nPrototype\n\nint aws_byte_buf_append_decoding_uri(struct aws_byte_buf *buffer, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_dynamic-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_dynamic","text":"aws_byte_buf_append_dynamic(to, from)\n\nCopies from to to. If to is too small, the buffer will be grown appropriately and the old contents copied to, before the new contents are appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nfrom and to may be the same buffer, permitting copying a buffer into itself.\n\nPrototype\n\nint aws_byte_buf_append_dynamic(struct aws_byte_buf *to, const struct aws_byte_cursor *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_dynamic_secure-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_dynamic_secure","text":"aws_byte_buf_append_dynamic_secure(to, from)\n\nCopies from to to. If to is too small, the buffer will be grown appropriately and the old contents copied over, before the new contents are appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nIf the buffer is grown, the old buffer will be securely cleared before getting freed.\n\nfrom and to may be the same buffer, permitting copying a buffer into itself.\n\nPrototype\n\nint aws_byte_buf_append_dynamic_secure(struct aws_byte_buf *to, const struct aws_byte_cursor *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_encoding_uri_param-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_encoding_uri_param","text":"aws_byte_buf_append_encoding_uri_param(buffer, cursor)\n\nWrites the uri query param encoding (passthrough alnum + '-' '_' '~' '.') of a UTF-8 cursor to a buffer For example, reading \"a b_c\" would write \"a20b_c\".\n\nPrototype\n\nint aws_byte_buf_append_encoding_uri_param( struct aws_byte_buf *buffer, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_encoding_uri_path-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_encoding_uri_path","text":"aws_byte_buf_append_encoding_uri_path(buffer, cursor)\n\nWrites the uri path encoding of a cursor to a buffer. This is the modified version of rfc3986 used by sigv4 signing.\n\nPrototype\n\nint aws_byte_buf_append_encoding_uri_path( struct aws_byte_buf *buffer, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_json_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_json_string","text":"aws_byte_buf_append_json_string(value, output)\n\nAppends a unformatted JSON string representation of the aws_json_value into the passed byte buffer. The byte buffer is expected to be already initialized so the function can append the JSON into it.\n\nNote: The byte buffer will automatically have its size extended if the JSON string is over the byte buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\nNote: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free the memory used, as it will NOT be called automatically.\n\nArguments\n\nvalue: The aws_json_value to format.\noutput: The destination for the JSON string\n\nReturns\n\nAWS_OP_SUCCESS if the JSON string was allocated to output without any errors Will return AWS_OP_ERR if the value passed is not an aws_json_value or if there was an error appending the JSON into the byte buffer.\n\nPrototype\n\nint aws_byte_buf_append_json_string(const struct aws_json_value *value, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_json_string_formatted-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_json_string_formatted","text":"aws_byte_buf_append_json_string_formatted(value, output)\n\nAppends a formatted JSON string representation of the aws_json_value into the passed byte buffer. The byte buffer is expected to already be initialized so the function can append the JSON into it.\n\nNote: The byte buffer will automatically have its size extended if the JSON string is over the byte buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\nNote: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free the memory used, as it will NOT be called automatically.\n\nArguments\n\nvalue: The aws_json_value to format.\noutput: The destination for the JSON string\n\nReturns\n\nAWS_OP_SUCCESS if the JSON string was allocated to output without any errors Will return AWS_OP_ERR if the value passed is not an aws_json_value or if there aws an error appending the JSON into the byte buffer.\n\nPrototype\n\nint aws_byte_buf_append_json_string_formatted(const struct aws_json_value *value, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_null_terminator-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_null_terminator","text":"aws_byte_buf_append_null_terminator(buf)\n\nAppends '\\0' at the end of the buffer.\n\nPrototype\n\nint aws_byte_buf_append_null_terminator(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_append_with_lookup-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_append_with_lookup","text":"aws_byte_buf_append_with_lookup(to, from, lookup_table)\n\nCopies from to to while converting bytes via the passed in lookup table. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. to->len will contain its original size plus the amount of data actually copied to to.\n\nfrom and to should not be the same buffer (overlap is not handled) lookup_table must be at least 256 bytes\n\nPrototype\n\nint aws_byte_buf_append_with_lookup( struct aws_byte_buf *AWS_RESTRICT to, const struct aws_byte_cursor *AWS_RESTRICT from, const uint8_t *lookup_table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_clean_up","text":"aws_byte_buf_clean_up(buf)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_byte_buf_clean_up(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_clean_up_secure-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_clean_up_secure","text":"aws_byte_buf_clean_up_secure(buf)\n\nEquivalent to calling aws_byte_buf_secure_zero and then aws_byte_buf_clean_up on the buffer.\n\nPrototype\n\nvoid aws_byte_buf_clean_up_secure(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_eq","text":"aws_byte_buf_eq(a, b)\n\nCompare two aws_byte_buf structures. Return whether their contents are equivalent.\n\nPrototype\n\nbool aws_byte_buf_eq(const struct aws_byte_buf *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_eq_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_eq_c_str","text":"aws_byte_buf_eq_c_str(buf, c_str)\n\nCompare an aws_byte_buf and a null-terminated string. Returns true if their contents are equivalent. The buffer should NOT contain a null-terminator, or the comparison will always return false.\n\nPrototype\n\nbool aws_byte_buf_eq_c_str(const struct aws_byte_buf *const buf, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_eq_c_str_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_eq_c_str_ignore_case","text":"aws_byte_buf_eq_c_str_ignore_case(buf, c_str)\n\nPerform a case-insensitive string comparison of an aws_byte_buf and a null-terminated string. Return whether their contents are equivalent. The buffer should NOT contain a null-terminator, or the comparison will always return false. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_buf_eq_c_str_ignore_case(const struct aws_byte_buf *const buf, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_eq_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_eq_ignore_case","text":"aws_byte_buf_eq_ignore_case(a, b)\n\nPerform a case-insensitive string comparison of two aws_byte_buf structures. Return whether their contents are equivalent. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_buf_eq_ignore_case(const struct aws_byte_buf *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_from_array-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_from_array","text":"aws_byte_buf_from_array(bytes, len)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_byte_buf aws_byte_buf_from_array(const void *bytes, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_from_c_str-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_from_c_str","text":"aws_byte_buf_from_c_str(c_str)\n\nFor creating a byte buffer from a null-terminated string literal.\n\nPrototype\n\nstruct aws_byte_buf aws_byte_buf_from_c_str(const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_from_empty_array-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_from_empty_array","text":"aws_byte_buf_from_empty_array(bytes, capacity)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_byte_buf aws_byte_buf_from_empty_array(const void *bytes, size_t capacity);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_init","text":"aws_byte_buf_init(buf, allocator, capacity)\n\nDocumentation not found.\n\nPrototype\n\nint aws_byte_buf_init(struct aws_byte_buf *buf, struct aws_allocator *allocator, size_t capacity);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_init_copy-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_init_copy","text":"aws_byte_buf_init_copy(dest, allocator, src)\n\nInitializes an aws_byte_buf structure base on another valid one. Requires: *src and *allocator are valid objects. Ensures: *dest is a valid aws_byte_buf with a new backing array dest->buffer which is a copy of the elements from src->buffer.\n\nPrototype\n\nint aws_byte_buf_init_copy( struct aws_byte_buf *dest, struct aws_allocator *allocator, const struct aws_byte_buf *src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_init_copy_from_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_init_copy_from_cursor","text":"aws_byte_buf_init_copy_from_cursor(dest, allocator, src)\n\nCopies src buffer into dest and sets the correct len and capacity. A new memory zone is allocated for dest->buffer. When dest is no longer needed it will have to be cleaned-up using aws_byte_buf_clean_up(dest). Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator. If src buffer is null the dest will have a null buffer with a len and a capacity of 0 Returns AWS_OP_SUCCESS in case of success or AWS_OP_ERR when memory can't be allocated.\n\nPrototype\n\nint aws_byte_buf_init_copy_from_cursor( struct aws_byte_buf *dest, struct aws_allocator *allocator, struct aws_byte_cursor src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_init_from_file-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_init_from_file","text":"aws_byte_buf_init_from_file(out_buf, alloc, filename)\n\nReads 'filename' into 'out_buf'. If successful, 'out_buf' is allocated and filled with the data; It is your responsibility to call 'aws_byte_buf_clean_up()' on it. Otherwise, 'out_buf' remains unused. In the very unfortunate case where some API needs to treat out_buf as a c_string, a null terminator is appended, but is not included as part of the length field.\n\nPrototype\n\nint aws_byte_buf_init_from_file(struct aws_byte_buf *out_buf, struct aws_allocator *alloc, const char *filename);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_init_from_file_with_size_hint-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_init_from_file_with_size_hint","text":"aws_byte_buf_init_from_file_with_size_hint(out_buf, alloc, filename, size_hint)\n\nSame as aws_byte_buf_init_from_file(), but for reading \"special files\" like /proc/cpuinfo. These files don't accurately report their size, so size_hint is used as initial buffer size, and the buffer grows until the while file is read.\n\nPrototype\n\nint aws_byte_buf_init_from_file_with_size_hint( struct aws_byte_buf *out_buf, struct aws_allocator *alloc, const char *filename, size_t size_hint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_is_valid","text":"aws_byte_buf_is_valid(buf)\n\nEvaluates the set of properties that define the shape of all valid aws_byte_buf structures. It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion).\n\nPrototype\n\nbool aws_byte_buf_is_valid(const struct aws_byte_buf *const buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_reserve-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_reserve","text":"aws_byte_buf_reserve(buffer, requested_capacity)\n\nAttempts to increase the capacity of a buffer to the requested capacity\n\nIf the the buffer's capacity is currently larger than the request capacity, the function does nothing (no shrink is performed).\n\nPrototype\n\nint aws_byte_buf_reserve(struct aws_byte_buf *buffer, size_t requested_capacity);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_reserve_relative-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_reserve_relative","text":"aws_byte_buf_reserve_relative(buffer, additional_length)\n\nConvenience function that attempts to increase the capacity of a buffer relative to the current length.\n\naws_byte_buf_reserve_relative(buf, x) ~~ aws_byte_buf_reserve(buf, buf->len + x)\n\nPrototype\n\nint aws_byte_buf_reserve_relative(struct aws_byte_buf *buffer, size_t additional_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_reset-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_reset","text":"aws_byte_buf_reset(buf, zero_contents)\n\nResets the len of the buffer to 0, but does not free the memory. The buffer can then be reused. Optionally zeroes the contents, if the \"zero_contents\" flag is true.\n\nPrototype\n\nvoid aws_byte_buf_reset(struct aws_byte_buf *buf, bool zero_contents);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_secure_zero-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_secure_zero","text":"aws_byte_buf_secure_zero(buf)\n\nSets all bytes of buffer to zero and resets len to zero.\n\nPrototype\n\nvoid aws_byte_buf_secure_zero(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write","text":"aws_byte_buf_write(buf, src, len)\n\nWrite specified number of bytes from array to byte buffer.\n\nOn success, returns true and updates the buffer length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write( struct aws_byte_buf *AWS_RESTRICT buf, const uint8_t *AWS_RESTRICT src, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_be16-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_be16","text":"aws_byte_buf_write_be16(buf, x)\n\nWrites a 16-bit integer in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be16(struct aws_byte_buf *buf, uint16_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_be24-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_be24","text":"aws_byte_buf_write_be24(buf, x)\n\nWrites low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer. Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be24(struct aws_byte_buf *buf, uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_be32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_be32","text":"aws_byte_buf_write_be32(buf, x)\n\nWrites a 32-bit integer in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be32(struct aws_byte_buf *buf, uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_be64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_be64","text":"aws_byte_buf_write_be64(buf, x)\n\nWrites a 64-bit integer in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be64(struct aws_byte_buf *buf, uint64_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_float_be32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_float_be32","text":"aws_byte_buf_write_float_be32(buf, x)\n\nWrites a 32-bit float in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_float_be32(struct aws_byte_buf *buf, float x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_float_be64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_float_be64","text":"aws_byte_buf_write_float_be64(buf, x)\n\nWrites a 64-bit float in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_float_be64(struct aws_byte_buf *buf, double x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_from_whole_buffer-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_from_whole_buffer","text":"aws_byte_buf_write_from_whole_buffer(buf, src)\n\nCopies all bytes from buffer to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_from_whole_buffer( struct aws_byte_buf *AWS_RESTRICT buf, struct aws_byte_buf src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_from_whole_cursor-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_from_whole_cursor","text":"aws_byte_buf_write_from_whole_cursor(buf, src)\n\nCopies all bytes from buffer to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_from_whole_cursor( struct aws_byte_buf *AWS_RESTRICT buf, struct aws_byte_cursor src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_from_whole_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_from_whole_string","text":"aws_byte_buf_write_from_whole_string(buf, src)\n\nCopies all bytes from string to buf.\n\nOn success, returns true and updates the buf pointer/length accordingly. If there is insufficient space in the buf, returns false, leaving the buf unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_from_whole_string( struct aws_byte_buf *AWS_RESTRICT buf, const struct aws_string *AWS_RESTRICT src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_to_capacity-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_to_capacity","text":"aws_byte_buf_write_to_capacity(buf, advancing_cursor)\n\nWithout increasing buf's capacity, write as much as possible from advancing_cursor into buf.\n\nbuf's len is updated accordingly. advancing_cursor is advanced so it contains the remaining unwritten parts. Returns the section of advancing_cursor which was written.\n\nThis function cannot fail. If buf is full (len == capacity) or advancing_len has 0 length, then buf and advancing_cursor are not altered and a cursor with 0 length is returned.\n\nExample: Given a buf with 2 bytes of space available and advancing_cursor with contents \"abc\". \"ab\" will be written to buf and buf->len will increase 2 and become equal to buf->capacity. advancing_cursor will advance so its contents become the unwritten \"c\". The returned cursor's contents will be the \"ab\" from the original advancing_cursor.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_buf_write_to_capacity( struct aws_byte_buf *buf, struct aws_byte_cursor *advancing_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_u8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_u8","text":"aws_byte_buf_write_u8(buf, c)\n\nCopies one byte to buffer.\n\nOn success, returns true and updates the cursor /length accordingly.\n\nIf there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_u8(struct aws_byte_buf *AWS_RESTRICT buf, uint8_t c);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_buf_write_u8_n-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_buf_write_u8_n","text":"aws_byte_buf_write_u8_n(buf, c, count)\n\nWrites one byte repeatedly to buffer (like memset)\n\nIf there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_u8_n(struct aws_byte_buf *buf, uint8_t c, size_t count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_advance-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_advance","text":"aws_byte_cursor_advance(cursor, len)\n\nTests if the given aws_byte_cursor has at least len bytes remaining. If so, *buf is advanced by len bytes (incrementing ->ptr and decrementing ->len), and an aws_byte_cursor referring to the first len bytes of the original *buf is returned. Otherwise, an aws_byte_cursor with ->ptr = NULL, ->len = 0 is returned.\n\nNote that if len is above (SIZE_MAX / 2), this function will also treat it as a buffer overflow, and return NULL without changing *buf.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_advance(struct aws_byte_cursor *const cursor, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_advance_nospec-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_advance_nospec","text":"aws_byte_cursor_advance_nospec(cursor, len)\n\nBehaves identically to aws_byte_cursor_advance, but avoids speculative execution potentially reading out-of-bounds pointers (by returning an empty ptr in such speculated paths).\n\nThis should generally be done when using an untrusted or data-dependent value for 'len', to avoid speculating into a path where cursor->ptr points outside the true ptr length.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_advance_nospec(struct aws_byte_cursor *const cursor, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_compare_lexical-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_compare_lexical","text":"aws_byte_cursor_compare_lexical(lhs, rhs)\n\nLexical (byte value) comparison of two byte cursors\n\nPrototype\n\nint aws_byte_cursor_compare_lexical(const struct aws_byte_cursor *lhs, const struct aws_byte_cursor *rhs);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_compare_lookup-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_compare_lookup","text":"aws_byte_cursor_compare_lookup(lhs, rhs, lookup_table)\n\nLexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first\n\nPrototype\n\nint aws_byte_cursor_compare_lookup( const struct aws_byte_cursor *lhs, const struct aws_byte_cursor *rhs, const uint8_t *lookup_table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_eq","text":"aws_byte_cursor_eq(a, b)\n\nCompare two aws_byte_cursor structures. Return whether their contents are equivalent.\n\nPrototype\n\nbool aws_byte_cursor_eq(const struct aws_byte_cursor *a, const struct aws_byte_cursor *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_eq_byte_buf-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_eq_byte_buf","text":"aws_byte_cursor_eq_byte_buf(a, b)\n\nCompare an aws_byte_cursor and an aws_byte_buf. Return whether their contents are equivalent.\n\nPrototype\n\nbool aws_byte_cursor_eq_byte_buf(const struct aws_byte_cursor *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_eq_byte_buf_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_eq_byte_buf_ignore_case","text":"aws_byte_cursor_eq_byte_buf_ignore_case(a, b)\n\nPerform a case-insensitive string comparison of an aws_byte_cursor and an aws_byte_buf. Return whether their contents are equivalent. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_eq_byte_buf_ignore_case(const struct aws_byte_cursor *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_eq_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_eq_c_str","text":"aws_byte_cursor_eq_c_str(cursor, c_str)\n\nCompare an aws_byte_cursor and a null-terminated string. Returns true if their contents are equivalent. The cursor should NOT contain a null-terminator, or the comparison will always return false.\n\nPrototype\n\nbool aws_byte_cursor_eq_c_str(const struct aws_byte_cursor *const cursor, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_eq_c_str_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_eq_c_str_ignore_case","text":"aws_byte_cursor_eq_c_str_ignore_case(cursor, c_str)\n\nPerform a case-insensitive string comparison of an aws_byte_cursor and a null-terminated string. Return whether their contents are equivalent. The cursor should NOT contain a null-terminator, or the comparison will always return false. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_eq_c_str_ignore_case(const struct aws_byte_cursor *const cursor, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_eq_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_eq_ignore_case","text":"aws_byte_cursor_eq_ignore_case(a, b)\n\nPerform a case-insensitive string comparison of two aws_byte_cursor structures. Return whether their contents are equivalent. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_eq_ignore_case(const struct aws_byte_cursor *a, const struct aws_byte_cursor *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_find_exact-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_find_exact","text":"aws_byte_cursor_find_exact(input_str, to_find, first_find)\n\nSearch for an exact byte match inside a cursor. The first match will be returned. Returns AWS_OP_SUCCESS on successful match and first_find will be set to the offset in input_str, and length will be the remaining length from input_str past the returned offset. If the match was not found, AWS_OP_ERR will be returned and AWS_ERROR_STRING_MATCH_NOT_FOUND will be raised.\n\nPrototype\n\nint aws_byte_cursor_find_exact( const struct aws_byte_cursor *AWS_RESTRICT input_str, const struct aws_byte_cursor *AWS_RESTRICT to_find, struct aws_byte_cursor *first_find);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_from_array-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_from_array","text":"aws_byte_cursor_from_array(bytes, len)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_array(const void *const bytes, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_from_buf-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_from_buf","text":"aws_byte_cursor_from_buf(buf)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_buf(const struct aws_byte_buf *const buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_from_c_str-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_from_c_str","text":"aws_byte_cursor_from_c_str(c_str)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_c_str(const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_from_string-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_from_string","text":"aws_byte_cursor_from_string(src)\n\nCreates an aws_byte_cursor from an existing string. If the src is NULL, it returns an empty cursor\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_string(const struct aws_string *src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_is_valid","text":"aws_byte_cursor_is_valid(cursor)\n\nEvaluates the set of properties that define the shape of all valid aws_byte_cursor structures. It is also a cheap check, in the sense it runs in constant time (i.e., no loops or recursion).\n\nPrototype\n\nbool aws_byte_cursor_is_valid(const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_left_trim_pred-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_left_trim_pred","text":"aws_byte_cursor_left_trim_pred(source, predicate)\n\nShrinks a byte cursor from the left for as long as the supplied predicate is true\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_left_trim_pred( const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_next_split-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_next_split","text":"aws_byte_cursor_next_split(input_str, split_on, substr)\n\nNo copies, no buffer allocations. Iterates over input_str, and returns the next substring between split_on instances relative to previous substr. Behaves similar to strtok with substr being used as state for next split.\n\nReturns true each time substr is set and false when there is no more splits (substr is set to empty in that case).\n\nExample usage. struct aws_byte_cursor substr = {0}; while (aws_byte_cursor_next_split(&input_str, ';', &substr)) { // ...use substr... }\n\nNote: It is the user's responsibility zero-initialize substr before the first call.\n\nEdge case rules are as follows: empty input will have single empty split. ex. \"\" splits into \"\" if input starts with split_on then first split is empty. ex \";A\" splits into \"\", \"A\" adjacent split tokens result in empty split. ex \"A;;B\" splits into \"A\", \"\", \"B\" If the input ends with split_on, last split is empty. ex. \"A;\" splits into \"A\", \"\"\n\nIt is the user's responsibility to make sure the input buffer stays in memory long enough to use the results.\n\nPrototype\n\nbool aws_byte_cursor_next_split( const struct aws_byte_cursor *AWS_RESTRICT input_str, char split_on, struct aws_byte_cursor *AWS_RESTRICT substr);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read","text":"aws_byte_cursor_read(cur, dest, len)\n\nReads specified length of data from byte cursor and copies it to the destination array.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read( struct aws_byte_cursor *AWS_RESTRICT cur, void *AWS_RESTRICT dest, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_and_fill_buffer-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_and_fill_buffer","text":"aws_byte_cursor_read_and_fill_buffer(cur, dest)\n\nReads as many bytes from cursor as size of buffer, and copies them to buffer.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_and_fill_buffer( struct aws_byte_cursor *AWS_RESTRICT cur, struct aws_byte_buf *AWS_RESTRICT dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_be16-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_be16","text":"aws_byte_cursor_read_be16(cur, var)\n\nReads a 16-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be16(struct aws_byte_cursor *cur, uint16_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_be24-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_be24","text":"aws_byte_cursor_read_be24(cur, var)\n\nReads an unsigned 24-bit value (3 bytes) in network byte order from cur, and places it in host byte order into 32-bit var. Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be24(struct aws_byte_cursor *cur, uint32_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_be32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_be32","text":"aws_byte_cursor_read_be32(cur, var)\n\nReads a 32-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be32(struct aws_byte_cursor *cur, uint32_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_be64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_be64","text":"aws_byte_cursor_read_be64(cur, var)\n\nReads a 64-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be64(struct aws_byte_cursor *cur, uint64_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_float_be32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_float_be32","text":"aws_byte_cursor_read_float_be32(cur, var)\n\nReads a 32-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_float_be32(struct aws_byte_cursor *cur, float *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_float_be64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_float_be64","text":"aws_byte_cursor_read_float_be64(cur, var)\n\nReads a 64-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_float_be64(struct aws_byte_cursor *cur, double *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_hex_u8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_hex_u8","text":"aws_byte_cursor_read_hex_u8(cur, var)\n\nReads 2 hex characters from ASCII/UTF-8 text to produce an 8-bit number. Accepts both lowercase 'a'-'f' and uppercase 'A'-'F'. For example: \"0F\" produces 15.\n\nOn success, returns true and advances the cursor by 2. If there is insufficient space in the cursor or an invalid character is encountered, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_hex_u8(struct aws_byte_cursor *cur, uint8_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_read_u8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_read_u8","text":"aws_byte_cursor_read_u8(cur, var)\n\nReads a single byte from cursor, placing it in *var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_u8(struct aws_byte_cursor *AWS_RESTRICT cur, uint8_t *AWS_RESTRICT var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_right_trim_pred-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_right_trim_pred","text":"aws_byte_cursor_right_trim_pred(source, predicate)\n\nShrinks a byte cursor from the right for as long as the supplied predicate is true\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_right_trim_pred( const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_satisfies_pred-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_satisfies_pred","text":"aws_byte_cursor_satisfies_pred(source, predicate)\n\nReturns true if the byte cursor's range of bytes all satisfy the predicate\n\nPrototype\n\nbool aws_byte_cursor_satisfies_pred(const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_split_on_char-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_split_on_char","text":"aws_byte_cursor_split_on_char(input_str, split_on, output)\n\nNo copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is an offset into the input_str and len is the length of that string in the original buffer.\n\nEdge case rules are as follows: if the input begins with split_on, an empty cursor will be the first entry in output. if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output. if the input ends with split_on, an empty cursor will be appended to the output.\n\nIt is the user's responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\nThe type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).\n\nIt is the user's responsibility to make sure the input buffer stays in memory long enough to use the results.\n\nPrototype\n\nint aws_byte_cursor_split_on_char( const struct aws_byte_cursor *AWS_RESTRICT input_str, char split_on, struct aws_array_list *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_split_on_char_n-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_split_on_char_n","text":"aws_byte_cursor_split_on_char_n(input_str, split_on, n, output)\n\nNo copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is an offset into the input_str and len is the length of that string in the original buffer. N is the max number of splits, if this value is zero, it will add all splits to the output.\n\nEdge case rules are as follows: if the input begins with split_on, an empty cursor will be the first entry in output if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output. if the input ends with split_on, an empty cursor will be appended to the output.\n\nIt is the user's responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\nIf the output array is not large enough, input_str will be updated to point to the first character after the last processed split_on instance.\n\nThe type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).\n\nIt is the user's responsibility to make sure the input buffer stays in memory long enough to use the results.\n\nPrototype\n\nint aws_byte_cursor_split_on_char_n( const struct aws_byte_cursor *AWS_RESTRICT input_str, char split_on, size_t n, struct aws_array_list *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_starts_with-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_starts_with","text":"aws_byte_cursor_starts_with(input, prefix)\n\nReturn true if the input starts with the prefix (exact byte comparison).\n\nPrototype\n\nbool aws_byte_cursor_starts_with(const struct aws_byte_cursor *input, const struct aws_byte_cursor *prefix);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_starts_with_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_starts_with_ignore_case","text":"aws_byte_cursor_starts_with_ignore_case(input, prefix)\n\nReturn true if the input starts with the prefix (case-insensitive). The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_starts_with_ignore_case(const struct aws_byte_cursor *input, const struct aws_byte_cursor *prefix);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_trim_pred-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_trim_pred","text":"aws_byte_cursor_trim_pred(source, predicate)\n\nShrinks a byte cursor from both sides for as long as the supplied predicate is true\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_trim_pred( const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_utf8_parse_u64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_utf8_parse_u64","text":"aws_byte_cursor_utf8_parse_u64(cursor, dst)\n\nRead entire cursor as ASCII/UTF-8 unsigned base-10 number. Stricter than strtoull(), which allows whitespace and inputs that start with \"0x\"\n\nExamples: \"0\" -> 0 \"123\" -> 123 \"00004\" -> 4 // leading zeros ok\n\nRejects things like: \"-1\" // negative numbers not allowed \"1,000\" // only characters 0-9 allowed \"\" // blank string not allowed \" 0 \" // whitespace not allowed \"0x0\" // hex not allowed \"FF\" // hex not allowed \"999999999999999999999999999999999999999999\" // larger than max u64\n\nPrototype\n\nint aws_byte_cursor_utf8_parse_u64(struct aws_byte_cursor cursor, uint64_t *dst);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_byte_cursor_utf8_parse_u64_hex-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_byte_cursor_utf8_parse_u64_hex","text":"aws_byte_cursor_utf8_parse_u64_hex(cursor, dst)\n\nRead entire cursor as ASCII/UTF-8 unsigned base-16 number with NO \"0x\" prefix.\n\nExamples: \"F\" -> 15 \"000000ff\" -> 255 // leading zeros ok \"Ff\" -> 255 // mixed case ok \"123\" -> 291 \"FFFFFFFFFFFFFFFF\" -> 18446744073709551616 // max u64\n\nRejects things like: \"0x0\" // 0x prefix not allowed \"\" // blank string not allowed \" F \" // whitespace not allowed \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" // larger than max u64\n\nPrototype\n\nint aws_byte_cursor_utf8_parse_u64_hex(struct aws_byte_cursor cursor, uint64_t *dst);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_c_string_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_c_string_is_valid","text":"aws_c_string_is_valid(str)\n\nBest-effort checks aws_string invariants, when the str->len is unknown\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_c_string_is_valid(const char *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_base_default_clear-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cache_base_default_clear","text":"aws_cache_base_default_clear(cache)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_cache_base_default_clear(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_base_default_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cache_base_default_destroy","text":"aws_cache_base_default_destroy(cache)\n\nDefault implementations\n\nPrototype\n\nvoid aws_cache_base_default_destroy(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_base_default_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_cache_base_default_find","text":"aws_cache_base_default_find(cache, key, p_value)\n\nDocumentation not found.\n\nPrototype\n\nint aws_cache_base_default_find(struct aws_cache *cache, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_base_default_get_element_count-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cache_base_default_get_element_count","text":"aws_cache_base_default_get_element_count(cache)\n\nDocumentation not found.\n\nPrototype\n\nsize_t aws_cache_base_default_get_element_count(const struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_base_default_remove-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cache_base_default_remove","text":"aws_cache_base_default_remove(cache, key)\n\nDocumentation not found.\n\nPrototype\n\nint aws_cache_base_default_remove(struct aws_cache *cache, const void *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_clear-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cache_clear","text":"aws_cache_clear(cache)\n\nClears all items from the cache.\n\nPrototype\n\nvoid aws_cache_clear(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cache_destroy","text":"aws_cache_destroy(cache)\n\nCleans up the cache. Elements in the cache will be evicted and cleanup callbacks will be invoked.\n\nPrototype\n\nvoid aws_cache_destroy(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_cache_find","text":"aws_cache_find(cache, key, p_value)\n\nFinds element in the cache by key. If found, *p_value will hold the stored value, and AWS_OP_SUCCESS will be returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\nIf any errors occur AWS_OP_ERR will be returned.\n\nPrototype\n\nint aws_cache_find(struct aws_cache *cache, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_get_element_count-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cache_get_element_count","text":"aws_cache_get_element_count(cache)\n\nReturns the number of elements in the cache.\n\nPrototype\n\nsize_t aws_cache_get_element_count(const struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_new_fifo-NTuple{6, Any}","page":"Home","title":"LibAwsCommon.aws_cache_new_fifo","text":"aws_cache_new_fifo(allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, max_items)\n\nInitializes the first-in-first-out cache. Sets up the underlying linked hash table. Once max_items elements have been added, the oldest(first-in) item will be removed. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.\n\nPrototype\n\nstruct aws_cache *aws_cache_new_fifo( struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t max_items);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_new_lifo-NTuple{6, Any}","page":"Home","title":"LibAwsCommon.aws_cache_new_lifo","text":"aws_cache_new_lifo(allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, max_items)\n\nInitializes the last-in-first-out cache. Sets up the underlying linked hash table. Once max_items elements have been added, the latest(last-in) item will be removed. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.\n\nPrototype\n\nstruct aws_cache *aws_cache_new_lifo( struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t max_items);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_new_lru-NTuple{6, Any}","page":"Home","title":"LibAwsCommon.aws_cache_new_lru","text":"aws_cache_new_lru(allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, max_items)\n\nInitializes the Least-recently-used cache. Sets up the underlying linked hash table. Once max_items elements have been added, the least recently used item will be removed. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.(Yes the one that was the answer to that interview question that one time).\n\nPrototype\n\nstruct aws_cache *aws_cache_new_lru( struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t max_items);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_put-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_cache_put","text":"aws_cache_put(cache, key, p_value)\n\nPuts p_value at key. If an element is already stored at key it will be replaced. If the cache is already full, an item will be removed based on the cache policy.\n\nPrototype\n\nint aws_cache_put(struct aws_cache *cache, const void *key, void *p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cache_remove-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cache_remove","text":"aws_cache_remove(cache, key)\n\nRemoves item at key from the cache.\n\nPrototype\n\nint aws_cache_remove(struct aws_cache *cache, const void *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_consume_next_single_element-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_consume_next_single_element","text":"aws_cbor_decoder_consume_next_single_element(decoder)\n\nConsume the next single element, without the content followed by the element.\n\nAs an example for the following cbor, this function will only consume the 0xBF, \"Start indefinite-length map\", not any content of the map represented. The next element to decode will start from 0x63 0xbf6346756ef563416d7421ff BF  Start indefinite-length map 63  First key, UTF-8 string length 3 46756e  \"Fun\" F5  First value, true 63  Second key, UTF-8 string length 3 416d74  \"Amt\" 21  Second value, -2 FF  \"break\"\n\nArguments\n\ndecoder: The decoder to parse data from\n\nReturns\n\nAWS_OP_SUCCESS successfully consumed the next element, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_cbor_decoder_consume_next_single_element(struct aws_cbor_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_consume_next_whole_data_item-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_consume_next_whole_data_item","text":"aws_cbor_decoder_consume_next_whole_data_item(decoder)\n\nConsume the next data item, includes all the content within the data item.\n\nAs an example for the following cbor, this function will consume all the data as it's only one cbor data item, an indefinite map with 2 <key, value> pair: 0xbf6346756ef563416d7421ff BF  Start indefinite-length map 63  First key, UTF-8 string length 3 46756e  \"Fun\" F5  First value, true 63  Second key, UTF-8 string length 3 416d74  \"Amt\" 21  Second value, -2 FF  \"break\"\n\nNotes: this function will not ensure the data item is well-formed.\n\nArguments\n\nsrc: The src to parse data from\n\nReturns\n\nAWS_OP_SUCCESS successfully consumed the next data item, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_cbor_decoder_consume_next_whole_data_item(struct aws_cbor_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_destroy","text":"aws_cbor_decoder_destroy(decoder)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_cbor_decoder *aws_cbor_decoder_destroy(struct aws_cbor_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_get_remaining_length-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_get_remaining_length","text":"aws_cbor_decoder_get_remaining_length(decoder)\n\nGet the length of the remaining bytes of the source. Once the source was decoded, it will be consumed, and result in decrease of the remaining length of bytes.\n\nArguments\n\ndecoder:\n\nReturns\n\nThe length of bytes remaining of the decoder source.\n\nPrototype\n\nsize_t aws_cbor_decoder_get_remaining_length(const struct aws_cbor_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_new-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_new","text":"aws_cbor_decoder_new(allocator, src)\n\nCreate a cbor decoder to take src to decode. The typical usage of decoder will be: - If the next element type only accept what expected, aws\\_cbor\\_decoder\\_pop\\_next\\_* - If the next element type accept different type, invoke aws_cbor_decoder_peek_type first, then based on the type to invoke corresponding aws\\_cbor\\_decoder\\_pop\\_next\\_* - If the next element type doesn't have corrsponding value, specifically: AWS_CBOR_TYPE_NULL, AWS_CBOR_TYPE_UNDEFINED, AWS_CBOR_TYPE_INF_*_START, AWS_CBOR_TYPE_BREAK, call aws_cbor_decoder_consume_next_single_element to consume it and continues for further decoding. - To ignore the next data item (the element and the content of it), aws_cbor_decoder_consume_next_whole_data_item\n\nNote: it's caller's responsibilty to keep the src outlive the decoder.\n\nArguments\n\nallocator:\nsrc: The src data to decode from.\n\nReturns\n\ndecoder\n\nPrototype\n\nstruct aws_cbor_decoder *aws_cbor_decoder_new(struct aws_allocator *allocator, struct aws_byte_cursor src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_peek_type-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_peek_type","text":"aws_cbor_decoder_peek_type(decoder, out_type)\n\nDecode the next element and store it in the decoder cache if there was no element cached. If there was element cached, just return the type of the cached element.\n\nArguments\n\ndecoder:\nout_type:\n\nReturns\n\nAWS_OP_SUCCESS if succeed, AWS_OP_ERR for any decoding error and corresponding error code will be raised.\n\nPrototype\n\nint aws_cbor_decoder_peek_type(struct aws_cbor_decoder *decoder, enum aws_cbor_type *out_type);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_array_start-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_array_start","text":"aws_cbor_decoder_pop_next_array_start(decoder, out_size)\n\nGet the next AWS_CBOR_TYPE_ARRAY_START element. Only consume the AWS_CBOR_TYPE_ARRAY_START element and set the size of array to *out_size, not the content of the array. The next *out_size cbor data items will be the content of the array for a valid cbor data,\n\nNotes: For indefinite-length, this function will fail with \"AWS_ERROR_CBOR_UNEXPECTED_TYPE\". The designed way to handle indefinite-length is: - Get AWS_CBOR_TYPE_INDEF_ARRAY_START from _peek_type - call aws_cbor_decoder_consume_next_single_element to pop the indefinite-length start. - Decode the next data item until AWS_CBOR_TYPE_BREAK read.\n\nArguments\n\ndecoder:\nout_size: store the size of array if succeed.\n\nReturns\n\nAWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_array_start(struct aws_cbor_decoder *decoder, uint64_t *out_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_boolean_val-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_boolean_val","text":"aws_cbor_decoder_pop_next_boolean_val(decoder, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_boolean_val(struct aws_cbor_decoder *decoder, bool *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_bytes_val-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_bytes_val","text":"aws_cbor_decoder_pop_next_bytes_val(decoder, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_bytes_val(struct aws_cbor_decoder *decoder, struct aws_byte_cursor *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_float_val-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_float_val","text":"aws_cbor_decoder_pop_next_float_val(decoder, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_float_val(struct aws_cbor_decoder *decoder, double *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_map_start-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_map_start","text":"aws_cbor_decoder_pop_next_map_start(decoder, out_size)\n\nGet the next AWS_CBOR_TYPE_MAP_START element. Only consume the AWS_CBOR_TYPE_MAP_START element and set the size of array to *out_size, not the content of the map. The next *out_size pair of cbor data items as key and value will be the content of the array for a valid cbor data,\n\nNotes: For indefinite-length, this function will fail with \"AWS_ERROR_CBOR_UNEXPECTED_TYPE\". The designed way to handle indefinite-length is: - Get AWS_CBOR_TYPE_INDEF_MAP_START from _peek_type - call aws_cbor_decoder_consume_next_single_element to pop the indefinite-length start. - Decode the next data item until AWS_CBOR_TYPE_BREAK read.\n\nArguments\n\ndecoder:\nout_size: store the size of map if succeed.\n\nReturns\n\nAWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_map_start(struct aws_cbor_decoder *decoder, uint64_t *out_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_negative_int_val-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_negative_int_val","text":"aws_cbor_decoder_pop_next_negative_int_val(decoder, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_negative_int_val(struct aws_cbor_decoder *decoder, uint64_t *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_tag_val-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_tag_val","text":"aws_cbor_decoder_pop_next_tag_val(decoder, out_tag_val)\n\nGet the next AWS_CBOR_TYPE_TAG element. Only consume the AWS_CBOR_TYPE_TAG element and set the tag value to *out_tag_val, not the content of the tagged. The next cbor data item will be the content of the tagged value for a valid cbor data.\n\nArguments\n\ndecoder:\nout_size: store the size of map if succeed.\n\nReturns\n\nAWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_tag_val(struct aws_cbor_decoder *decoder, uint64_t *out_tag_val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_text_val-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_text_val","text":"aws_cbor_decoder_pop_next_text_val(decoder, out)\n\nDocumentation not found.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_text_val(struct aws_cbor_decoder *decoder, struct aws_byte_cursor *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_decoder_pop_next_unsigned_int_val-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_decoder_pop_next_unsigned_int_val","text":"aws_cbor_decoder_pop_next_unsigned_int_val(decoder, out)\n\nGet the next element based on the type. If the next element doesn't match the expected type. Error will be raised. If the next element already been cached, it will consume the cached item when no error was returned. Specifically: AWS_CBOR_TYPE_UINT - aws_cbor_decoder_pop_next_unsigned_int_val AWS_CBOR_TYPE_NEGINT - aws_cbor_decoder_pop_next_negative_int_val, it represents (-1 - *out) AWS_CBOR_TYPE_FLOAT - aws_cbor_decoder_pop_next_float_val AWS_CBOR_TYPE_BYTES - aws_cbor_decoder_pop_next_bytes_val AWS_CBOR_TYPE_TEXT - aws_cbor_decoder_pop_next_text_val\n\nArguments\n\ndecoder:\nout:\n\nReturns\n\nAWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_cbor_decoder_pop_next_unsigned_int_val(struct aws_cbor_decoder *decoder, uint64_t *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_destroy","text":"aws_cbor_encoder_destroy(encoder)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_cbor_encoder *aws_cbor_encoder_destroy(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_get_encoded_data-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_get_encoded_data","text":"aws_cbor_encoder_get_encoded_data(encoder)\n\nGet the current encoded data from encoder. The encoded data has the same lifetime as the encoder, and once any other function call invoked for the encoder, the encoded data is no longer valid.\n\nArguments\n\nencoder:\n\nReturns\n\nstruct aws_byte_cursor from the encoder buffer.\n\nPrototype\n\nstruct aws_byte_cursor aws_cbor_encoder_get_encoded_data(const struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_new-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_new","text":"aws_cbor_encoder_new(allocator)\n\nCreate a new cbor encoder. Creating a encoder with a temporay buffer. Every aws_cbor_encoder_write_* will encode directly into the buffer to follow the encoded data.\n\nArguments\n\nallocator:\n\nReturns\n\naws_cbor_encoder\n\nPrototype\n\nstruct aws_cbor_encoder *aws_cbor_encoder_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_reset-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_reset","text":"aws_cbor_encoder_reset(encoder)\n\nClear the current encoded buffer from encoder.\n\nArguments\n\nencoder:\n\nPrototype\n\nvoid aws_cbor_encoder_reset(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_array_start-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_array_start","text":"aws_cbor_encoder_write_array_start(encoder, number_entries)\n\nEncode a AWS_CBOR_TYPE_ARRAY_START value to \"smallest possible\" in encoder's buffer. Referring to RFC8949 section 4.2.1 The \"number_entries\" is the cbor data items should be followed as the content of the array. Notes: it's user's responsibility to keep the integrity of the array to be encoded.\n\nArguments\n\nencoder:\nnumber_entries: The number of data item in array.\n\nPrototype\n\nvoid aws_cbor_encoder_write_array_start(struct aws_cbor_encoder *encoder, size_t number_entries);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_bool-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_bool","text":"aws_cbor_encoder_write_bool(encoder, value)\n\nEncode a simple value AWS_CBOR_TYPE_BOOL\n\nArguments\n\nencoder:\n\nPrototype\n\nvoid aws_cbor_encoder_write_bool(struct aws_cbor_encoder *encoder, bool value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_break-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_break","text":"aws_cbor_encoder_write_break(encoder)\n\nEncode a simple value AWS_CBOR_TYPE_BREAK\n\nNotes: no error checking, it's user's responsibility to track the break to close the corresponding indef_start\n\nPrototype\n\nvoid aws_cbor_encoder_write_break(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_bytes-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_bytes","text":"aws_cbor_encoder_write_bytes(encoder, from)\n\nEncode a AWS_CBOR_TYPE_BYTES value to \"smallest possible\" in encoder's buffer. Referring to RFC8949 section 4.2.1, the length of \"from\" will be encoded first and then the value of \"from\" will be followed.\n\nArguments\n\nencoder:\nfrom: value to encode.\n\nPrototype\n\nvoid aws_cbor_encoder_write_bytes(struct aws_cbor_encoder *encoder, struct aws_byte_cursor from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_float-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_float","text":"aws_cbor_encoder_write_float(encoder, value)\n\nEncode a AWS_CBOR_TYPE_FLOAT value to \"smallest possible\", but will not be encoded into half-precision float, as it's not well supported cross languages.\n\nTo be more specific, it will be encoded into integer/negative/float (Order with priority) when the conversation will not cause precision loss.\n\nArguments\n\nencoder:\nvalue: value to encode.\n\nPrototype\n\nvoid aws_cbor_encoder_write_float(struct aws_cbor_encoder *encoder, double value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_indef_array_start-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_indef_array_start","text":"aws_cbor_encoder_write_indef_array_start(encoder)\n\nEncode a AWS_CBOR_TYPE_INDEF_ARRAY_START\n\nNotes: no error checking, it's user's responsibility to add corresponding data and the break to close the indef_start\n\nPrototype\n\nvoid aws_cbor_encoder_write_indef_array_start(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_indef_bytes_start-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_indef_bytes_start","text":"aws_cbor_encoder_write_indef_bytes_start(encoder)\n\nEncode a AWS_CBOR_TYPE_INDEF_BYTES_START\n\nNotes: no error checking, it's user's responsibility to add corresponding data and the break to close the indef_start\n\nPrototype\n\nvoid aws_cbor_encoder_write_indef_bytes_start(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_indef_map_start-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_indef_map_start","text":"aws_cbor_encoder_write_indef_map_start(encoder)\n\nEncode a AWS_CBOR_TYPE_INDEF_MAP_START\n\nNotes: no error checking, it's user's responsibility to add corresponding data and the break to close the indef_start\n\nPrototype\n\nvoid aws_cbor_encoder_write_indef_map_start(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_indef_text_start-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_indef_text_start","text":"aws_cbor_encoder_write_indef_text_start(encoder)\n\nEncode a AWS_CBOR_TYPE_INDEF_TEXT_START\n\nNotes: no error checking, it's user's responsibility to add corresponding data and the break to close the indef_start\n\nPrototype\n\nvoid aws_cbor_encoder_write_indef_text_start(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_map_start-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_map_start","text":"aws_cbor_encoder_write_map_start(encoder, number_entries)\n\nEncode a AWS_CBOR_TYPE_MAP_START value to \"smallest possible\" in encoder's buffer. Referring to RFC8949 section 4.2.1 The \"number_entries\" is the number of pair of cbor data items as key and value should be followed as the content of the map.\n\nNotes: it's user's responsibility to keep the integrity of the map to be encoded.\n\nArguments\n\nencoder:\nnumber_entries: The number of data item in map.\n\nPrototype\n\nvoid aws_cbor_encoder_write_map_start(struct aws_cbor_encoder *encoder, size_t number_entries);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_negint-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_negint","text":"aws_cbor_encoder_write_negint(encoder, value)\n\nEncode a AWS_CBOR_TYPE_NEGINT value to \"smallest possible\" in encoder's buffer. It represents (-1 - value). Referring to RFC8949 section 4.2.1\n\nArguments\n\nencoder:\nvalue: The argument to encode to negative integer, which is (-1 - expected_val)\n\nPrototype\n\nvoid aws_cbor_encoder_write_negint(struct aws_cbor_encoder *encoder, uint64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_null-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_null","text":"aws_cbor_encoder_write_null(encoder)\n\nEncode a simple value AWS_CBOR_TYPE_NULL\n\nArguments\n\nencoder:\n\nPrototype\n\nvoid aws_cbor_encoder_write_null(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_tag-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_tag","text":"aws_cbor_encoder_write_tag(encoder, tag_number)\n\nEncode a AWS_CBOR_TYPE_TAG value to \"smallest possible\" in encoder's buffer. Referring to RFC8949 section 4.2.1 The following cbor data item will be the content of the tagged value. Notes: it's user's responsibility to keep the integrity of the tagged value to follow the RFC8949 section 3.4\n\nArguments\n\nencoder:\ntag_number: The tag value to encode.\n\nPrototype\n\nvoid aws_cbor_encoder_write_tag(struct aws_cbor_encoder *encoder, uint64_t tag_number);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_text-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_text","text":"aws_cbor_encoder_write_text(encoder, from)\n\nEncode a AWS_CBOR_TYPE_TEXT value to \"smallest possible\" in encoder's buffer. Referring to RFC8949 section 4.2.1, the length of \"from\" will be encoded first and then the value of \"from\" will be followed.\n\nArguments\n\nencoder:\nfrom: value to encode.\n\nPrototype\n\nvoid aws_cbor_encoder_write_text(struct aws_cbor_encoder *encoder, struct aws_byte_cursor from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_uint-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_uint","text":"aws_cbor_encoder_write_uint(encoder, value)\n\nEncode a AWS_CBOR_TYPE_UINT value to \"smallest possible\" in encoder's buffer. Referring to RFC8949 section 4.2.1\n\nTODO: maybe add a width of the encoded value.\n\nArguments\n\nencoder:\nvalue: value to encode.\n\nPrototype\n\nvoid aws_cbor_encoder_write_uint(struct aws_cbor_encoder *encoder, uint64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_encoder_write_undefined-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_encoder_write_undefined","text":"aws_cbor_encoder_write_undefined(encoder)\n\nEncode a simple value AWS_CBOR_TYPE_UNDEFINED\n\nArguments\n\nencoder:\n\nPrototype\n\nvoid aws_cbor_encoder_write_undefined(struct aws_cbor_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cbor_type_cstr-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cbor_type_cstr","text":"aws_cbor_type_cstr(type)\n\nReturn c-string for aws_cbor_type\n\nPrototype\n\nconst char *aws_cbor_type_cstr(enum aws_cbor_type type);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_char_is_space-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_char_is_space","text":"aws_char_is_space(c)\n\nEvaluates if a char is a white character.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_char_is_space(uint8_t c);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cli_dispatch_on_subcommand-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_cli_dispatch_on_subcommand","text":"aws_cli_dispatch_on_subcommand(argc, argv, dispatch_table, table_length, user_data)\n\nDispatches the current command line arguments with a subcommand from the second input argument in argv[], if dispatch table contains a command that matches the argument. When the command is dispatched, argc and argv will be updated to reflect the new argument count. The cli options are required to come after the subcommand. If either, no dispatch was found or there was no argument passed to the program, this function will return AWS_OP_ERR. Check aws_last_error() for details on the error.\n\nArguments\n\nargc: number of arguments passed to int main()\nargv: the arguments passed to int main()\nparse_cb,: optional, specify NULL if you don't want to handle this. This argument is for parsing \"meta\" commands from the command line options prior to dispatch occurring.\ndispatch_table: table containing functions and command name to dispatch on.\ntable_length: number of entries in dispatch_table.\n\nReturns\n\nAWS_OP_SUCCESS(0) on success, AWS_OP_ERR(-1) on failure\n\nPrototype\n\nint aws_cli_dispatch_on_subcommand( int argc, char *const argv[], struct aws_cli_subcommand_dispatch *dispatch_table, int table_length, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cli_getopt_long-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_cli_getopt_long","text":"aws_cli_getopt_long(argc, argv, optstring, longopts, longindex)\n\nA mostly compliant implementation of posix getopt_long(). Parses command-line arguments. argc is the number of command line arguments passed in argv. optstring contains the legitimate option characters. The option characters correspond to aws_cli_option::val. If the character is followed by a :, the option requires an argument. If it is followed by '::', the argument is optional (not implemented yet).\n\nlongopts, is an array of struct aws_cli_option. These are the allowed options for the program. The last member of the array must be zero initialized.\n\nIf longindex is non-null, it will be set to the index in longopts, for the found option.\n\nReturns option val if it was found, '?' if an option was encountered that was not specified in the option string, 0x02 (START_OF_TEXT) will be returned if a positional argument was encountered. returns -1 when all arguments that can be parsed have been parsed.\n\nPrototype\n\nint aws_cli_getopt_long( int argc, char *const argv[], const char *optstring, const struct aws_cli_option *longopts, int *longindex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cli_reset_state-Tuple{}","page":"Home","title":"LibAwsCommon.aws_cli_reset_state","text":"aws_cli_reset_state()\n\nResets global parser state for use in another parser run for the application.\n\nPrototype\n\nvoid aws_cli_reset_state(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_clz_i32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_clz_i32","text":"aws_clz_i32(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_i32(int32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_clz_i64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_clz_i64","text":"aws_clz_i64(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_i64(int64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_clz_size-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_clz_size","text":"aws_clz_size(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_size(size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_clz_u32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_clz_u32","text":"aws_clz_u32(n)\n\nSearch from the MSB to LSB, looking for a 1\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_u32(uint32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_clz_u64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_clz_u64","text":"aws_clz_u64(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_u64(uint64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_common_fatal_assert_library_initialized-Tuple{}","page":"Home","title":"LibAwsCommon.aws_common_fatal_assert_library_initialized","text":"aws_common_fatal_assert_library_initialized()\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_common_fatal_assert_library_initialized(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_common_library_clean_up-Tuple{}","page":"Home","title":"LibAwsCommon.aws_common_library_clean_up","text":"aws_common_library_clean_up()\n\nShuts down the internal data structures used by aws-c-common.\n\nPrototype\n\nvoid aws_common_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_common_library_init-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_common_library_init","text":"aws_common_library_init(allocator)\n\nInitializes internal data structures used by aws-c-common. Must be called before using any functionality in aws-c-common.\n\nPrototype\n\nvoid aws_common_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_clean_up","text":"aws_condition_variable_clean_up(condition_variable)\n\nCleans up a condition variable.\n\nPrototype\n\nvoid aws_condition_variable_clean_up(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_init-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_init","text":"aws_condition_variable_init(condition_variable)\n\nInitializes a condition variable.\n\nPrototype\n\nint aws_condition_variable_init(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_notify_all-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_notify_all","text":"aws_condition_variable_notify_all(condition_variable)\n\nNotifies/Wakes all waiting threads.\n\nPrototype\n\nint aws_condition_variable_notify_all(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_notify_one-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_notify_one","text":"aws_condition_variable_notify_one(condition_variable)\n\nNotifies/Wakes one waiting thread\n\nPrototype\n\nint aws_condition_variable_notify_one(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_wait-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_wait","text":"aws_condition_variable_wait(condition_variable, mutex)\n\nWaits the calling thread on a notification from another thread. This function must be called with the mutex locked by the calling thread otherwise the behavior is undefined. Spurious wakeups can occur and to avoid this causing any problems use the _pred version of this function.\n\nPrototype\n\nint aws_condition_variable_wait(struct aws_condition_variable *condition_variable, struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_wait_for-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_wait_for","text":"aws_condition_variable_wait_for(condition_variable, mutex, time_to_wait)\n\nWaits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in nanoseconds. This function must be called with the mutex locked by the calling thread otherwise the behavior is undefined. Spurious wakeups can occur and to avoid this causing any problems use the _pred version of this function.\n\nPrototype\n\nint aws_condition_variable_wait_for( struct aws_condition_variable *condition_variable, struct aws_mutex *mutex, int64_t time_to_wait);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_wait_for_pred-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_wait_for_pred","text":"aws_condition_variable_wait_for_pred(condition_variable, mutex, time_to_wait, pred, pred_ctx)\n\nWaits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in nanoseconds. If predicate returns false, the wait is reentered, otherwise control returns to the caller. This function must be called with the mutex locked by the calling thread otherwise the behavior is undefined.\n\nPrototype\n\nint aws_condition_variable_wait_for_pred( struct aws_condition_variable *condition_variable, struct aws_mutex *mutex, int64_t time_to_wait, aws_condition_predicate_fn *pred, void *pred_ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_condition_variable_wait_pred-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_condition_variable_wait_pred","text":"aws_condition_variable_wait_pred(condition_variable, mutex, pred, pred_ctx)\n\nWaits the calling thread on a notification from another thread. If predicate returns false, the wait is reentered, otherwise control returns to the caller. This function must be called with the mutex locked by the calling thread otherwise the behavior is undefined.\n\nPrototype\n\nint aws_condition_variable_wait_pred( struct aws_condition_variable *condition_variable, struct aws_mutex *mutex, aws_condition_predicate_fn *pred, void *pred_ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cpu_has_feature-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cpu_has_feature","text":"aws_cpu_has_feature(feature_name)\n\nReturns true if a cpu feature is supported, false otherwise.\n\nPrototype\n\nbool aws_cpu_has_feature(enum aws_cpu_feature_name feature_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cross_process_lock_release-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_cross_process_lock_release","text":"aws_cross_process_lock_release(instance_lock)\n\nReleases the lock so the next caller (may be another process) can get an instance of the lock.\n\nPrototype\n\nvoid aws_cross_process_lock_release(struct aws_cross_process_lock *instance_lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_cross_process_lock_try_acquire-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_cross_process_lock_try_acquire","text":"aws_cross_process_lock_try_acquire(allocator, instance_nonce)\n\nAttempts to acquire a system-wide (not per process or per user) lock scoped by instance_nonce. For any given unique nonce, a lock will be returned by the first caller. Subsequent calls will return NULL and raise AWS_ERROR_MUTEX_CALLER_NOT_OWNER until the either the process owning the lock exits or the program owning the lock calls aws_cross_process_lock_release() explicitly.\n\nIf the process exits before the lock is released, the kernel will unlock it for the next consumer.\n\nPrototype\n\nstruct aws_cross_process_lock *aws_cross_process_lock_try_acquire( struct aws_allocator *allocator, struct aws_byte_cursor instance_nonce);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_crt_statistics_handler_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler_destroy","text":"aws_crt_statistics_handler_destroy(handler)\n\ncompletely destroys a statistics handler. The handler's cleanup function must clean up the impl portion completely (including its allocation, if done separately).\n\nPrototype\n\nvoid aws_crt_statistics_handler_destroy(struct aws_crt_statistics_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_crt_statistics_handler_get_report_interval_ms-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler_get_report_interval_ms","text":"aws_crt_statistics_handler_get_report_interval_ms(handler)\n\nQueries the frequency (via an interval in milliseconds) which a statistics handler would like to be informed of statistics.\n\nPrototype\n\nuint64_t aws_crt_statistics_handler_get_report_interval_ms(struct aws_crt_statistics_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_crt_statistics_handler_process_statistics-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_crt_statistics_handler_process_statistics","text":"aws_crt_statistics_handler_process_statistics(handler, interval, stats, context)\n\nSubmits a list of statistics objects to a statistics handler for processing\n\nhandler - the statistics handler that will process the statistics objects interval - time period over which the statistics were gathered stats - list of pointers to structures that can be case to aws_crt_statistics_base (i.e. have category as a first member) context - (optional) additional context specific to where the statistics handler has been attached\n\nPrototype\n\nvoid aws_crt_statistics_handler_process_statistics( struct aws_crt_statistics_handler *handler, struct aws_crt_statistics_sample_interval *interval, struct aws_array_list *stats, void *context);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ctz_i32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ctz_i32","text":"aws_ctz_i32(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_i32(int32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ctz_i64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ctz_i64","text":"aws_ctz_i64(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_i64(int64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ctz_size-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ctz_size","text":"aws_ctz_size(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_size(size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ctz_u32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ctz_u32","text":"aws_ctz_u32(n)\n\nSearch from the LSB to MSB, looking for a 1\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_u32(uint32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ctz_u64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ctz_u64","text":"aws_ctz_u64(n)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_u64(uint64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_as_epoch_secs-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_date_time_as_epoch_secs","text":"aws_date_time_as_epoch_secs(dt)\n\nDocumentation not found.\n\nPrototype\n\ndouble aws_date_time_as_epoch_secs(const struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_as_millis-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_date_time_as_millis","text":"aws_date_time_as_millis(dt)\n\nDocumentation not found.\n\nPrototype\n\nuint64_t aws_date_time_as_millis(const struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_as_nanos-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_date_time_as_nanos","text":"aws_date_time_as_nanos(dt)\n\nDocumentation not found.\n\nPrototype\n\nuint64_t aws_date_time_as_nanos(const struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_day_of_week-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_day_of_week","text":"aws_date_time_day_of_week(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nenum aws_date_day_of_week aws_date_time_day_of_week(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_diff-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_diff","text":"aws_date_time_diff(a, b)\n\nreturns the difference of a and b (a - b) in seconds.\n\nPrototype\n\ntime_t aws_date_time_diff(const struct aws_date_time *a, const struct aws_date_time *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_dst-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_dst","text":"aws_date_time_dst(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_date_time_dst(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_hour-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_hour","text":"aws_date_time_hour(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nuint8_t aws_date_time_hour(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_init_epoch_millis-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_init_epoch_millis","text":"aws_date_time_init_epoch_millis(dt, ms_since_epoch)\n\nInitializes dt to be the time represented in milliseconds since unix epoch.\n\nPrototype\n\nvoid aws_date_time_init_epoch_millis(struct aws_date_time *dt, uint64_t ms_since_epoch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_init_epoch_secs-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_init_epoch_secs","text":"aws_date_time_init_epoch_secs(dt, sec_ms)\n\nInitializes dt to be the time represented in seconds.millis since unix epoch.\n\nPrototype\n\nvoid aws_date_time_init_epoch_secs(struct aws_date_time *dt, double sec_ms);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_init_from_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_init_from_str","text":"aws_date_time_init_from_str(dt, date_str, fmt)\n\nInitializes dt to be the time represented by date_str in format 'fmt'. Returns AWS_OP_SUCCESS if the string was successfully parsed, returns AWS_OP_ERR if parsing failed.\n\nThe parser is lenient regarding AWS_DATE_FORMAT_ISO_8601 vs AWS_DATE_FORMAT_ISO_8601_BASIC. Regardless of which you pass in, both \"2002-10-02T08:05:09Z\" and \"20021002T080509Z\" would be accepted.\n\nNotes for AWS_DATE_FORMAT_RFC822: If no time zone information is provided, it is assumed to be local time (please don't do this).\n\nOnly time zones indicating Universal Time (e.g. Z, UT, UTC, or GMT), or offsets from UTC (e.g. +0100, -0700), are accepted.\n\nReally, it's just better if you always use Universal Time.\n\nPrototype\n\nint aws_date_time_init_from_str( struct aws_date_time *dt, const struct aws_byte_buf *date_str, enum aws_date_format fmt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_init_from_str_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_init_from_str_cursor","text":"aws_date_time_init_from_str_cursor(dt, date_str_cursor, fmt)\n\naws_date_time_init variant that takes a byte_cursor rather than a byte_buf\n\nPrototype\n\nint aws_date_time_init_from_str_cursor( struct aws_date_time *dt, const struct aws_byte_cursor *date_str_cursor, enum aws_date_format fmt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_init_now-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_date_time_init_now","text":"aws_date_time_init_now(dt)\n\nInitializes dt to be the current system time.\n\nPrototype\n\nvoid aws_date_time_init_now(struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_minute-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_minute","text":"aws_date_time_minute(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nuint8_t aws_date_time_minute(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_month-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_month","text":"aws_date_time_month(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nenum aws_date_month aws_date_time_month(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_month_day-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_month_day","text":"aws_date_time_month_day(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nuint8_t aws_date_time_month_day(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_second-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_second","text":"aws_date_time_second(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nuint8_t aws_date_time_second(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_to_local_time_short_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_to_local_time_short_str","text":"aws_date_time_to_local_time_short_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted short date string in local time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_local_time_short_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_to_local_time_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_to_local_time_str","text":"aws_date_time_to_local_time_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted date string in local time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_local_time_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_to_utc_time_short_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_to_utc_time_short_str","text":"aws_date_time_to_utc_time_short_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted short date string in utc time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_utc_time_short_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_to_utc_time_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_to_utc_time_str","text":"aws_date_time_to_utc_time_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted date string in utc time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_utc_time_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_date_time_year-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_date_time_year","text":"aws_date_time_year(dt, local_time)\n\nDocumentation not found.\n\nPrototype\n\nuint16_t aws_date_time_year(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_debug_break-Tuple{}","page":"Home","title":"LibAwsCommon.aws_debug_break","text":"aws_debug_break()\n\nIf a debugger is attached to the process, trip a breakpoint.\n\nPrototype\n\nvoid aws_debug_break(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_decode_utf8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_decode_utf8","text":"aws_decode_utf8(bytes, options)\n\nDecode a complete string of UTF8/ASCII text. Text is always validated according to RFC-3629 (you may perform additional validation in the on_codepoint callback). The text does not need to begin with a UTF8 BOM. If you need to decode text incrementally as you receive it, use aws_utf8_decoder_new() instead.\n\nArguments\n\nbytes: Text to decode.\noptions: Options for decoding. If NULL is passed, the text is simply validated.\n\nReturns\n\nAWS_OP_SUCCESS if successful. An error is raised if the text is not valid, or the on_codepoint callback raises an error.\n\nPrototype\n\nint aws_decode_utf8(struct aws_byte_cursor bytes, const struct aws_utf8_decoder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_default_allocator-Tuple{}","page":"Home","title":"LibAwsCommon.aws_default_allocator","text":"aws_default_allocator()\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_allocator *aws_default_allocator(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_default_thread_options-Tuple{}","page":"Home","title":"LibAwsCommon.aws_default_thread_options","text":"aws_default_thread_options()\n\nReturns an instance of system default thread options.\n\nPrototype\n\nconst struct aws_thread_options *aws_default_thread_options(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_device_random_buffer-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_device_random_buffer","text":"aws_device_random_buffer(output)\n\nFill the rest of a buffer with unpredictably random bytes, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_buffer(struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_device_random_buffer_append-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_device_random_buffer_append","text":"aws_device_random_buffer_append(output, n)\n\nWrite N unpredictably random bytes to a buffer, suitable for cryptographic use. If there is insufficient space in the buffer, AWS_ERROR_SHORT_BUFFER is raised and the buffer will be unchanged.\n\nPrototype\n\nint aws_device_random_buffer_append(struct aws_byte_buf *output, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_device_random_u16-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_device_random_u16","text":"aws_device_random_u16(output)\n\nGet an unpredictably random 16bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u16(uint16_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_device_random_u32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_device_random_u32","text":"aws_device_random_u32(output)\n\nGet an unpredictably random 32bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u32(uint32_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_device_random_u64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_device_random_u64","text":"aws_device_random_u64(output)\n\nGet an unpredictably random 64bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u64(uint64_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_device_random_u8-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_device_random_u8","text":"aws_device_random_u8(output)\n\nGet an unpredictably random 8bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u8(uint8_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_create-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_directory_create","text":"aws_directory_create(dir_path)\n\nCreates a directory if it doesn't currently exist. If the directory already exists, it's ignored and assumed successful.\n\nReturns AWS_OP_SUCCESS on success. Otherwise, check aws_last_error().\n\nPrototype\n\nint aws_directory_create(const struct aws_string *dir_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_delete-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_directory_delete","text":"aws_directory_delete(dir_path, recursive)\n\nDeletes a directory. If the directory is not empty, this will fail unless the recursive parameter is set to true. If recursive is true then the entire directory and all of its contents will be deleted. If it is set to false, the directory will be deleted only if it is empty. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise, aws_last_error() will contain the error that occurred. If the directory doesn't exist, AWS_OP_SUCCESS is still returned.\n\nPrototype\n\nint aws_directory_delete(const struct aws_string *dir_path, bool recursive);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_entry_iterator_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_directory_entry_iterator_destroy","text":"aws_directory_entry_iterator_destroy(iterator)\n\nCleanup and deallocate iterator\n\nPrototype\n\nvoid aws_directory_entry_iterator_destroy(struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_entry_iterator_get_value-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_directory_entry_iterator_get_value","text":"aws_directory_entry_iterator_get_value(iterator)\n\nGets the aws_directory_entry value for iterator at the current position. Returns NULL if the iterator contains no entries.\n\nPrototype\n\nconst struct aws_directory_entry *aws_directory_entry_iterator_get_value( const struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_entry_iterator_new-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_directory_entry_iterator_new","text":"aws_directory_entry_iterator_new(allocator, path)\n\nCreates a read-only iterator of a directory starting at path. If path is invalid or there's any other error condition, NULL will be returned. Call aws_last_error() for the exact error in that case.\n\nPrototype\n\nstruct aws_directory_iterator *aws_directory_entry_iterator_new( struct aws_allocator *allocator, const struct aws_string *path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_entry_iterator_next-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_directory_entry_iterator_next","text":"aws_directory_entry_iterator_next(iterator)\n\nMoves the iterator to the next entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available.\n\nPrototype\n\nint aws_directory_entry_iterator_next(struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_entry_iterator_previous-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_directory_entry_iterator_previous","text":"aws_directory_entry_iterator_previous(iterator)\n\nMoves the iterator to the previous entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available.\n\nPrototype\n\nint aws_directory_entry_iterator_previous(struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_exists-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_directory_exists","text":"aws_directory_exists(dir_path)\n\nReturns true if the directory currently exists. Otherwise, it returns false.\n\nPrototype\n\nbool aws_directory_exists(const struct aws_string *dir_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_or_file_move-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_directory_or_file_move","text":"aws_directory_or_file_move(from, to)\n\nMoves directory at from to to. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise, aws_last_error() will contain the error that occurred.\n\nPrototype\n\nint aws_directory_or_file_move(const struct aws_string *from, const struct aws_string *to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_directory_traverse-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_directory_traverse","text":"aws_directory_traverse(allocator, path, recursive, on_entry, user_data)\n\nTraverse a directory starting at path.\n\nIf you want the traversal to recurse the entire directory, pass recursive as true. Passing false for this parameter will only iterate the contents of the directory, but will not descend into any directories it encounters.\n\nIf recursive is set to true, the traversal is performed post-order, depth-first (for practical reasons such as deleting a directory that contains subdirectories or files).\n\nreturns AWS_OP_SUCCESS(0) on success.\n\nPrototype\n\nint aws_directory_traverse( struct aws_allocator *allocator, const struct aws_string *path, bool recursive, aws_on_directory_entry *on_entry, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_error_debug_str-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_error_debug_str","text":"aws_error_debug_str(err)\n\nReturns libname concatenated with error string.\n\nPrototype\n\nconst char *aws_error_debug_str(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_error_lib_name-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_error_lib_name","text":"aws_error_lib_name(err)\n\nReturns the error lib name corresponding to err.\n\nPrototype\n\nconst char *aws_error_lib_name(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_error_name-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_error_name","text":"aws_error_name(err)\n\nReturns the enum name corresponding to err.\n\nPrototype\n\nconst char *aws_error_name(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_error_str-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_error_str","text":"aws_error_str(err)\n\nReturns the error str corresponding to err.\n\nPrototype\n\nconst char *aws_error_str(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_fatal_assert-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_fatal_assert","text":"aws_fatal_assert(cond_str, file, line)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_fatal_assert(const char *cond_str, const char *file, int line) AWS_ATTRIBUTE_NORETURN;\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_file_delete-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_file_delete","text":"aws_file_delete(file_path)\n\nDeletes a file. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise, aws_last_error() will contain the error that occurred. If the file doesn't exist, AWS_OP_SUCCESS is still returned.\n\nPrototype\n\nint aws_file_delete(const struct aws_string *file_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_file_get_length-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_file_get_length","text":"aws_file_get_length(file, length)\n\nWrapper for os-specific file length query. We can't use fseek(END, 0) because support for it is not technically required.\n\nUnix flavors call fstat, while Windows variants use GetFileSize on a HANDLE queried from the libc FILE pointer.\n\nPrototype\n\nint aws_file_get_length(FILE *file, int64_t *length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_fopen-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_fopen","text":"aws_fopen(file_path, mode)\n\nDeprecated - Use aws_fopen_safe() instead, avoid const char * in public APIs. Opens file at file_path using mode. Returns the FILE pointer if successful. Otherwise, aws_last_error() will contain the error that occurred\n\nPrototype\n\nFILE *aws_fopen(const char *file_path, const char *mode);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_fopen_safe-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_fopen_safe","text":"aws_fopen_safe(file_path, mode)\n\nOpens file at file_path using mode. Returns the FILE pointer if successful. Otherwise, aws_last_error() will contain the error that occurred\n\nPrototype\n\nFILE *aws_fopen_safe(const struct aws_string *file_path, const struct aws_string *mode);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_fseek-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_fseek","text":"aws_fseek(file, offset, whence)\n\nWrapper for highest-resolution platform-dependent seek implementation. Maps to:\n\n_fseeki64() on windows fseeko() on linux\n\nwhence can either be SEEK_SET or SEEK_END\n\nReturns AWS_OP_SUCCESS, or AWS_OP_ERR (after an error has been raised).\n\nPrototype\n\nint aws_fseek(FILE *file, int64_t offset, int whence);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_cpu_count_for_group-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_get_cpu_count_for_group","text":"aws_get_cpu_count_for_group(group_idx)\n\nFor a group, returns the number of CPUs it contains.\n\nPrototype\n\nsize_t aws_get_cpu_count_for_group(uint16_t group_idx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_cpu_group_count-Tuple{}","page":"Home","title":"LibAwsCommon.aws_get_cpu_group_count","text":"aws_get_cpu_group_count()\n\nReturns the logical processor groupings on the system (such as multiple numa nodes).\n\nPrototype\n\nuint16_t aws_get_cpu_group_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_cpu_ids_for_group-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_get_cpu_ids_for_group","text":"aws_get_cpu_ids_for_group(group_idx, cpu_ids_array, cpu_ids_array_length)\n\nFills in cpu_ids_array with the cpu_id's for the group. To obtain the size to allocate for cpu_ids_array and the value for argument for cpu_ids_array_length, call aws_get_cpu_count_for_group().\n\nPrototype\n\nvoid aws_get_cpu_ids_for_group(uint16_t group_idx, struct aws_cpu_info *cpu_ids_array, size_t cpu_ids_array_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_env-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_get_env","text":"aws_get_env(allocator, name)\n\nGet the value of an environment variable. If the variable is not set, the output string will be set to NULL. Not thread-safe\n\nPrototype\n\nstruct aws_string *aws_get_env(struct aws_allocator *allocator, const char *name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_env_nonempty-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_get_env_nonempty","text":"aws_get_env_nonempty(allocator, name)\n\nGet the value of an environment variable. If the variable is not set or is empty, the output string will be set to NULL. Not thread-safe\n\nPrototype\n\nstruct aws_string *aws_get_env_nonempty(struct aws_allocator *allocator, const char *name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_environment_value-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_get_environment_value","text":"aws_get_environment_value(allocator, variable_name, value_out)\n\nDEPRECATED Please use the aws_get_env or aws_get_env_nonempty instead. Get the value of an environment variable. If the variable is not set, the output string will be set to NULL. Not thread-safe\n\nPrototype\n\nint aws_get_environment_value( struct aws_allocator *allocator, const struct aws_string *variable_name, struct aws_string **value_out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_hard_limit_io_handles-Tuple{}","page":"Home","title":"LibAwsCommon.aws_get_hard_limit_io_handles","text":"aws_get_hard_limit_io_handles()\n\nReturns the hard limit for max io handles (max fds in unix terminology). This limit is one more than the actual limit. This limit cannot be increased without sudo permissions.\n\nPrototype\n\nsize_t aws_get_hard_limit_io_handles(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_home_directory-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_get_home_directory","text":"aws_get_home_directory(allocator)\n\nReturns the current user's home directory.\n\nPrototype\n\nstruct aws_string *aws_get_home_directory(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_pid-Tuple{}","page":"Home","title":"LibAwsCommon.aws_get_pid","text":"aws_get_pid()\n\nReturns the current process's PID (process id).\n\nReturns\n\nPID as int\n\nPrototype\n\nint aws_get_pid(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_platform_build_os-Tuple{}","page":"Home","title":"LibAwsCommon.aws_get_platform_build_os","text":"aws_get_platform_build_os()\n\nReturns the OS this was built under\n\nPrototype\n\nenum aws_platform_os aws_get_platform_build_os(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_platform_directory_separator-Tuple{}","page":"Home","title":"LibAwsCommon.aws_get_platform_directory_separator","text":"aws_get_platform_directory_separator()\n\nReturns the directory separator used by the local platform\n\nPrototype\n\nchar aws_get_platform_directory_separator(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_get_soft_limit_io_handles-Tuple{}","page":"Home","title":"LibAwsCommon.aws_get_soft_limit_io_handles","text":"aws_get_soft_limit_io_handles()\n\nReturns the soft limit for max io handles (max fds in unix terminology). This limit is one more than the actual limit. The soft limit can be changed up to the hard limit by any process regardless of permissions.\n\nPrototype\n\nsize_t aws_get_soft_limit_io_handles(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_gmtime-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_gmtime","text":"aws_gmtime(time, t)\n\nCross platform friendly version of gmtime_r\n\nPrototype\n\nvoid aws_gmtime(time_t time, struct tm *t);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_array_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_array_ignore_case","text":"aws_hash_array_ignore_case(array, len)\n\nCase-insensitive hash function for array containing ASCII or UTF-8 text.\n\nPrototype\n\nuint64_t aws_hash_array_ignore_case(const void *array, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_byte_cursor_ptr-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_byte_cursor_ptr","text":"aws_hash_byte_cursor_ptr(item)\n\nConvenience hash function for struct aws_byte_cursor. Hash is same as used on the string bytes by aws_hash_c_string.\n\nPrototype\n\nuint64_t aws_hash_byte_cursor_ptr(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_byte_cursor_ptr_ignore_case-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_byte_cursor_ptr_ignore_case","text":"aws_hash_byte_cursor_ptr_ignore_case(item)\n\nCase-insensitive hash function for aws_byte_cursors stored in an aws_hash_table. For case-sensitive hashing, use aws_hash_byte_cursor_ptr().\n\nPrototype\n\nuint64_t aws_hash_byte_cursor_ptr_ignore_case(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_c_string-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_c_string","text":"aws_hash_c_string(item)\n\nConvenience hash function for NULL-terminated C-strings\n\nPrototype\n\nuint64_t aws_hash_c_string(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_callback_c_str_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_callback_c_str_eq","text":"aws_hash_callback_c_str_eq(a, b)\n\nConvenience eq callback for NULL-terminated C-strings\n\nPrototype\n\nbool aws_hash_callback_c_str_eq(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_callback_string_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_callback_string_destroy","text":"aws_hash_callback_string_destroy(a)\n\nConvenience destroy callback for AWS strings\n\nPrototype\n\nvoid aws_hash_callback_string_destroy(void *a);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_callback_string_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_callback_string_eq","text":"aws_hash_callback_string_eq(a, b)\n\nConvenience eq callback for AWS strings\n\nPrototype\n\nbool aws_hash_callback_string_eq(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_combine-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_combine","text":"aws_hash_combine(item1, item2)\n\nDocumentation not found.\n\nPrototype\n\nuint64_t aws_hash_combine(uint64_t item1, uint64_t item2);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_compare_uint64_t_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_compare_uint64_t_eq","text":"aws_hash_compare_uint64_t_eq(a, b)\n\nHelper function to compare hash keys that are uint64_t values.\n\nPrototype\n\nbool aws_hash_compare_uint64_t_eq(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_iter_begin-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_iter_begin","text":"aws_hash_iter_begin(map)\n\nReturns an iterator to be used for iterating through a hash table. Iterator will already point to the first element of the table it finds, which can be accessed as iter.element.\n\nThis function cannot fail, but if there are no elements in the table, the returned iterator will return true for aws_hash_iter_done(&iter).\n\nPrototype\n\nstruct aws_hash_iter aws_hash_iter_begin(const struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_iter_delete-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_iter_delete","text":"aws_hash_iter_delete(iter, destroy_contents)\n\nDeletes the element currently pointed-to by the hash iterator. After calling this method, the element member of the iterator should not be accessed until the next call to aws_hash_iter_next.\n\nArguments\n\ndestroy_contents: If true, the destructors for the key and value will be called.\n\nPrototype\n\nvoid aws_hash_iter_delete(struct aws_hash_iter *iter, bool destroy_contents);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_iter_done-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_iter_done","text":"aws_hash_iter_done(iter)\n\nReturns true if iterator is done iterating through table, false otherwise. If this is true, the iterator will not include an element of the table.\n\nPrototype\n\nbool aws_hash_iter_done(const struct aws_hash_iter *iter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_iter_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_iter_is_valid","text":"aws_hash_iter_is_valid(iter)\n\nGiven a pointer to a hash_iter, checks that it is well-formed, with all data-structure invariants.\n\nPrototype\n\nbool aws_hash_iter_is_valid(const struct aws_hash_iter *iter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_iter_next-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_iter_next","text":"aws_hash_iter_next(iter)\n\nUpdates iterator so that it points to next element of hash table.\n\nThis and the two previous functions are designed to be used together with the following idiom:\n\nfor (struct aws_hash_iter iter = aws_hash_iter_begin(&map); !aws_hash_iter_done(&iter); aws_hash_iter_next(&iter)) { const key\\_type key = *(const key\\_type *)iter.element.key; value\\_type value = *(value\\_type *)iter.element.value; // etc. }\n\nNote that calling this on an iter which is \"done\" is idempotent: i.e. it will return another iter which is \"done\".\n\nPrototype\n\nvoid aws_hash_iter_next(struct aws_hash_iter *iter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_ptr-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_ptr","text":"aws_hash_ptr(item)\n\nConvenience hash function which hashes the pointer value directly, without dereferencing. This can be used in cases where pointer identity is desired, or where a uintptr_t is encoded into a const void *.\n\nPrototype\n\nuint64_t aws_hash_ptr(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_string-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_string","text":"aws_hash_string(item)\n\nConvenience hash function for struct aws_strings. Hash is same as used on the string bytes by aws_hash_c_string.\n\nPrototype\n\nuint64_t aws_hash_string(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_clean_up","text":"aws_hash_table_clean_up(map)\n\nDeletes every element from map and frees all associated memory. destroy_fn will be called for each element. aws_hash_table_init must be called before reusing the hash table.\n\nThis method is idempotent.\n\nPrototype\n\nvoid aws_hash_table_clean_up(struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_clear-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_clear","text":"aws_hash_table_clear(map)\n\nRemoves every element from the hash map. destroy_fn will be called for each element.\n\nPrototype\n\nvoid aws_hash_table_clear(struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_create-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_create","text":"aws_hash_table_create(map, key, p_elem, was_created)\n\nAttempts to locate an element at key. If no such element was found, creates a new element, with value initialized to NULL. In either case, a pointer to the element is placed in *p_elem.\n\nIf was_created is non-NULL, *was_created is set to 0 if an existing element was found, or 1 is a new element was created.\n\nReturns AWS_OP_SUCCESS if an item was found or created. Raises AWS_ERROR_OOM if hash table expansion was required and memory allocation failed.\n\nPrototype\n\nint aws_hash_table_create( struct aws_hash_table *map, const void *key, struct aws_hash_element **p_elem, int *was_created);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_eq-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_eq","text":"aws_hash_table_eq(a, b, value_eq)\n\nCompares two hash tables for equality. Both hash tables must have equivalent key comparators; values will be compared using the comparator passed into this function. The key hash function does not need to be equivalent between the two hash tables.\n\nPrototype\n\nbool aws_hash_table_eq( const struct aws_hash_table *a, const struct aws_hash_table *b, aws_hash_callback_eq_fn *value_eq);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_find","text":"aws_hash_table_find(map, key, p_elem)\n\nAttempts to locate an element at key. If the element is found, a pointer to the value is placed in *p_elem; if it is not found, *pElem is set to NULL. Either way, AWS_OP_SUCCESS is returned.\n\nThis method does not change the state of the hash table. Therefore, it is safe to call _find from multiple threads on the same hash table, provided no mutating operations happen in parallel.\n\nCalling code may update the value in the hash table by modifying **pElem after a successful find. However, this pointer is not guaranteed to remain usable after a subsequent call to _put, _delete, _clear, or _clean_up.\n\nPrototype\n\nint aws_hash_table_find(const struct aws_hash_table *map, const void *key, struct aws_hash_element **p_elem);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_foreach-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_foreach","text":"aws_hash_table_foreach(map, callback, context)\n\nIterates through every element in the map and invokes the callback on that item. Iteration is performed in an arbitrary, implementation-defined order, and is not guaranteed to be consistent across invocations.\n\nThe callback may change the value associated with the key by overwriting the value pointed-to by value. In this case, the on_element_removed callback will not be invoked, unless the callback invokes AWS_COMMON_HASH_TABLE_ITER_DELETE (in which case the on_element_removed is given the updated value).\n\nThe callback must return a bitmask of zero or more of the following values ORed together:\n\nAWS_COMMON_HASH_TABLE_ITER_CONTINUE - Continues iteration to the next element (if not set, iteration stops) # AWS_COMMON_HASH_TABLE_ITER_DELETE - Deletes the current value and continues iteration. destroy_fn will NOT be invoked. # AWS_COMMON_HASH_TABLE_ITER_ERROR - Stop iteration with error. No action will be taken for the current value and the value before this. No rolling back. The deleted value before will NOT be back. aws_hash_table_foreach returns AWS_OP_ERR after stropping the iteration.\n\nInvoking any method which may change the contents of the hashtable during iteration results in undefined behavior. However, you may safely invoke non-mutating operations during an iteration.\n\nThis operation is mutating only if AWS_COMMON_HASH_TABLE_ITER_DELETE is returned at some point during iteration. Otherwise, it is non-mutating and is safe to invoke in parallel with other non-mutating operations.\n\nPrototype\n\nint aws_hash_table_foreach( struct aws_hash_table *map, int (*callback)(void *context, struct aws_hash_element *p_element), void *context);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_get_entry_count-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_get_entry_count","text":"aws_hash_table_get_entry_count(map)\n\nReturns the current number of entries in the table.\n\nPrototype\n\nsize_t aws_hash_table_get_entry_count(const struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_init-NTuple{7, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_init","text":"aws_hash_table_init(map, alloc, size, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn)\n\nInitializes a hash map with initial capacity for 'size' elements without resizing. Uses hash_fn to compute the hash of each element. equals_fn to compute equality of two keys. Whenever an element is removed without being returned, destroy_key_fn is run on the pointer to the key and destroy_value_fn is run on the pointer to the value. Either or both may be NULL if a callback is not desired in this case.\n\nPrototype\n\nint aws_hash_table_init( struct aws_hash_table *map, struct aws_allocator *alloc, size_t size, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_is_valid","text":"aws_hash_table_is_valid(map)\n\nBest-effort check of hash_table_state data-structure invariants\n\nPrototype\n\nbool aws_hash_table_is_valid(const struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_move-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_move","text":"aws_hash_table_move(to, from)\n\nMoves the hash table in 'from' to 'to'. After this move, 'from' will be identical to the state of the original 'to' hash table, and 'to' will be in the same state as if it had been passed to aws_hash_table_clean_up (that is, it will have no memory allocated, and it will be safe to either discard it or call aws_hash_table_clean_up again).\n\nNote that 'to' will not be cleaned up. You should make sure that 'to' is either uninitialized or cleaned up before moving a hashtable into it.\n\nPrototype\n\nvoid aws_hash_table_move(struct aws_hash_table *AWS_RESTRICT to, struct aws_hash_table *AWS_RESTRICT from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_put-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_put","text":"aws_hash_table_put(map, key, value, was_created)\n\nInserts a new element at key, with the given value. If another element exists at that key, the old element will be overwritten; both old key and value objects will be destroyed.\n\nIf was_created is non-NULL, *was_created is set to 0 if an existing element was found, or 1 is a new element was created.\n\nReturns AWS_OP_SUCCESS if an item was found or created. Raises AWS_ERROR_OOM if hash table expansion was required and memory allocation failed.\n\nPrototype\n\nint aws_hash_table_put(struct aws_hash_table *map, const void *key, void *value, int *was_created);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_remove-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_remove","text":"aws_hash_table_remove(map, key, p_value, was_present)\n\nRemoves element at key. Always returns AWS_OP_SUCCESS.\n\nIf pValue is non-NULL, the existing value (if any) is moved into (*value) before removing from the table, and destroy_fn is _not_ invoked. If pValue is NULL, then (if the element existed) destroy_fn will be invoked on the element being removed.\n\nIf was_present is non-NULL, it is set to 0 if the element was not present, or 1 if it was present (and is now removed).\n\nPrototype\n\nint aws_hash_table_remove( struct aws_hash_table *map, const void *key, struct aws_hash_element *p_value, int *was_present);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_remove_element-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_remove_element","text":"aws_hash_table_remove_element(map, p_value)\n\nRemoves element already known (typically by find()).\n\np_value should point to a valid element returned by create() or find().\n\nNOTE: DO NOT call this method from inside of a aws_hash_table_foreach callback, return AWS_COMMON_HASH_TABLE_ITER_DELETE instead.\n\nPrototype\n\nint aws_hash_table_remove_element(struct aws_hash_table *map, struct aws_hash_element *p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_table_swap-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hash_table_swap","text":"aws_hash_table_swap(a, b)\n\nSafely swaps two hash tables. Note that we swap the entirety of the hash table, including which allocator is associated.\n\nNeither hash table is required to be initialized; if one or both is uninitialized, then the uninitialized state is also swapped.\n\nPrototype\n\nvoid aws_hash_table_swap(struct aws_hash_table *AWS_RESTRICT a, struct aws_hash_table *AWS_RESTRICT b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hash_uint64_t_by_identity-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hash_uint64_t_by_identity","text":"aws_hash_uint64_t_by_identity(item)\n\nHelper function to hash keys that are uint64_t values.\n\nThe function is not a strong hash function in any sense; it merely reflects the uint64 value back. Do not use this function as a hash if you need the properties of a strong hash function.\n\nPrototype\n\nuint64_t aws_hash_uint64_t_by_identity(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hex_compute_decoded_len-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hex_compute_decoded_len","text":"aws_hex_compute_decoded_len(to_decode_len, decoded_len)\n\ncomputes the length necessary to store the result of aws_hex_decode(). returns -1 on failure, and 0 on success. decoded_len will be set on success.\n\nPrototype\n\nint aws_hex_compute_decoded_len(size_t to_decode_len, size_t *decoded_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hex_compute_encoded_len-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hex_compute_encoded_len","text":"aws_hex_compute_encoded_len(to_encode_len, encoded_length)\n\ncomputes the length necessary to store the result of aws_hex_encode(). returns -1 on failure, and 0 on success. encoded_length will be set on success.\n\nPrototype\n\nint aws_hex_compute_encoded_len(size_t to_encode_len, size_t *encoded_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hex_decode-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hex_decode","text":"aws_hex_decode(to_decode, output)\n\nBase 16 (hex) decodes the contents of to_decode and stores the result in output. If output is NULL, output_size will be set to what the output_size should be.\n\nPrototype\n\nint aws_hex_decode(const struct aws_byte_cursor *AWS_RESTRICT to_decode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hex_encode-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hex_encode","text":"aws_hex_encode(to_encode, output)\n\nBase 16 (hex) encodes the contents of to_encode and stores the result in output. Assumes the buffer is empty and does not resize on insufficient capacity.\n\nPrototype\n\nint aws_hex_encode(const struct aws_byte_cursor *AWS_RESTRICT to_encode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hex_encode_append_dynamic-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_hex_encode_append_dynamic","text":"aws_hex_encode_append_dynamic(to_encode, output)\n\nBase 16 (hex) encodes the contents of to_encode and appends the result in output. Grows the destination buffer dynamically if necessary.\n\nPrototype\n\nint aws_hex_encode_append_dynamic( const struct aws_byte_cursor *AWS_RESTRICT to_encode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_high_res_clock_get_ticks-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_high_res_clock_get_ticks","text":"aws_high_res_clock_get_ticks(timestamp)\n\nGet ticks in nanoseconds (usually 100 nanosecond precision) on the high resolution clock (most-likely TSC). This clock has no bearing on the actual system time. On success, timestamp will be set.\n\nPrototype\n\nint aws_high_res_clock_get_ticks(uint64_t *timestamp);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_host_utils_is_ipv4-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_host_utils_is_ipv4","text":"aws_host_utils_is_ipv4(host)\n\nDetermine whether host cursor is IPv4 string.\n\nPrototype\n\nbool aws_host_utils_is_ipv4(struct aws_byte_cursor host);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_host_utils_is_ipv6-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_host_utils_is_ipv6","text":"aws_host_utils_is_ipv6(host, is_uri_encoded)\n\nDetermine whether host cursor is IPv6 string. Supports checking for uri encoded strings and scoped literals.\n\nPrototype\n\nbool aws_host_utils_is_ipv6(struct aws_byte_cursor host, bool is_uri_encoded);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hton16-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hton16","text":"aws_hton16(x)\n\nConvert 16 bit integer from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_hton16(uint16_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hton32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hton32","text":"aws_hton32(x)\n\nConvert 32 bit integer from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_hton32(uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_hton64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_hton64","text":"aws_hton64(x)\n\nConvert 64 bit integer from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_hton64(uint64_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_htonf32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_htonf32","text":"aws_htonf32(x)\n\nConvert 32 bit float from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL float aws_htonf32(float x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_htonf64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_htonf64","text":"aws_htonf64(x)\n\nConvert 64 bit double from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL double aws_htonf64(double x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_init_memory_usage_for_current_process-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_init_memory_usage_for_current_process","text":"aws_init_memory_usage_for_current_process(memory_usage)\n\nGet memory usage for current process. Raises AWS_ERROR_SYS_CALL_FAILURE on failure.\n\nPrototype\n\nint aws_init_memory_usage_for_current_process(struct aws_memory_usage_stats *memory_usage);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_is_any_directory_separator-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_is_any_directory_separator","text":"aws_is_any_directory_separator(value)\n\nReturns true iff the character is a directory separator on ANY supported platform.\n\nPrototype\n\nbool aws_is_any_directory_separator(char value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_is_big_endian-Tuple{}","page":"Home","title":"LibAwsCommon.aws_is_big_endian","text":"aws_is_big_endian()\n\nReturns 1 if machine is big endian, 0 if little endian. If you compile with even -O1 optimization, this check is completely optimized out at compile time and code which calls \"if (aws_is_big_endian())\" will do the right thing without branching.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_is_big_endian(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_is_debugger_present-Tuple{}","page":"Home","title":"LibAwsCommon.aws_is_debugger_present","text":"aws_is_debugger_present()\n\nReturns true if a debugger is currently attached to the process.\n\nPrototype\n\nbool aws_is_debugger_present(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_is_mem_zeroed-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_is_mem_zeroed","text":"aws_is_mem_zeroed(buf, bufsize)\n\nReturns whether each byte is zero.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_is_mem_zeroed(const void *buf, size_t bufsize);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_is_power_of_two-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_is_power_of_two","text":"aws_is_power_of_two(x)\n\nFunction to check if x is power of 2\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_is_power_of_two(const size_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_isalnum-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_isalnum","text":"aws_isalnum(ch)\n\nLike isalnum(), but ignores C locale. Returns true if ch has the value of ASCII/UTF-8: 'a'-'z', 'A'-'Z', or '0'-'9'.\n\nPrototype\n\nbool aws_isalnum(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_isalpha-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_isalpha","text":"aws_isalpha(ch)\n\nLike isalpha(), but ignores C locale. Returns true if ch has the value of ASCII/UTF-8: 'a'-'z' or 'A'-'Z'.\n\nPrototype\n\nbool aws_isalpha(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_isdigit-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_isdigit","text":"aws_isdigit(ch)\n\nLike isdigit(). Returns true if ch has the value of ASCII/UTF-8: '0'-'9'.\n\nNote: C's built-in isdigit() is also supposed to ignore the C locale, but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits\"\n\nPrototype\n\nbool aws_isdigit(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_isspace-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_isspace","text":"aws_isspace(ch)\n\nLike isspace(), but ignores C locale. Return true if ch has the value of ASCII/UTF-8: space (0x20), form feed (0x0C), line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B).\n\nPrototype\n\nbool aws_isspace(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_isxdigit-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_isxdigit","text":"aws_isxdigit(ch)\n\nLike isxdigit(). Returns true if ch has the value of ASCII/UTF-8: '0'-'9', 'a'-'f', or 'A'-'F'.\n\nNote: C's built-in isxdigit() is also supposed to ignore the C locale, but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits\"\n\nPrototype\n\nbool aws_isxdigit(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_const_iterate_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_const_iterate_array","text":"aws_json_const_iterate_array(array, on_value, user_data)\n\niterates through values of an array. iteration is sequential starting with 0th element.\n\nArguments\n\narray: array to iterate over.\non_value: callback for when value is encountered.\nuser_data: user data to pass back in callback.\n\nReturns\n\nAWS_OP_SUCCESS when iteration finishes completely or exits early, AWS_OP_ERR if value is not an array.\n\nPrototype\n\nint aws_json_const_iterate_array( const struct aws_json_value *array, aws_json_on_value_encountered_const_fn *on_value, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_const_iterate_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_const_iterate_object","text":"aws_json_const_iterate_object(object, on_member, user_data)\n\niterates through members of the object. iteration is sequential in order fields were initially parsed.\n\nArguments\n\nobject: object to iterate over.\non_member: callback for when member is encountered.\nuser_data: user data to pass back in callback.\n\nReturns\n\nAWS_OP_SUCCESS when iteration finishes completely or exits early, AWS_OP_ERR if value is not an object.\n\nPrototype\n\nint aws_json_const_iterate_object( const struct aws_json_value *object, aws_json_on_member_encountered_const_fn *on_member, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_get_array_element-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_get_array_element","text":"aws_json_get_array_element(array, index)\n\nReturns the aws_json_value at the given index in the array aws_json_value.\n\nArguments\n\narray: The array aws_json_value.\nindex: The index of the aws_json_value you want to access.\n\nReturns\n\nA pointer to the aws_json_value at the given index in the array, otherwise NULL.\n\nPrototype\n\nstruct aws_json_value *aws_json_get_array_element(const struct aws_json_value *array, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_get_array_size-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_get_array_size","text":"aws_json_get_array_size(array)\n\nReturns the number of items in the array aws_json_value.\n\nArguments\n\narray: The array aws_json_value.\n\nReturns\n\nThe number of items in the array_json_value.\n\nPrototype\n\nsize_t aws_json_get_array_size(const struct aws_json_value *array);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_add_array_element-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_add_array_element","text":"aws_json_value_add_array_element(array, value)\n\nAdds a aws_json_value to the given array aws_json_value.\n\nNote that the aws_json_value will be destroyed when the aws_json_value array is destroyed by calling \"aws_json_destroy()\"\n\nArguments\n\narray: The array aws_json_value you want to add an aws_json_value to.\nvalue: The aws_json_value you want to add.\n\nReturns\n\nAWS_OP_SUCCESS if adding the aws_json_value was successful. Will return AWS_OP_ERR if the array passed is invalid.\n\nPrototype\n\nint aws_json_value_add_array_element(struct aws_json_value *array, const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_add_to_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_add_to_object","text":"aws_json_value_add_to_object(object, key, value)\n\nAdds a aws_json_value to a object aws_json_value.\n\nNote that the aws_json_value will be destroyed when the aws_json_value object is destroyed by calling \"aws_json_destroy()\" Note: might be slower than c_str version due to internal copy\n\nArguments\n\nobject: The object aws_json_value you want to add a value to.\nkey: The key to add the aws_json_value at.\nvalue: The aws_json_value you want to add.\n\nReturns\n\nAWS_OP_SUCCESS if adding was successful. Will return AWS_OP_ERROR if the object passed is invalid or if the passed key is already in use in the object.\n\nPrototype\n\nint aws_json_value_add_to_object( struct aws_json_value *object, struct aws_byte_cursor key, struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_add_to_object_c_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_add_to_object_c_str","text":"aws_json_value_add_to_object_c_str(object, key, value)\n\nAdds a aws_json_value to a object aws_json_value.\n\nNote that the aws_json_value will be destroyed when the aws_json_value object is destroyed by calling \"aws_json_destroy()\"\n\nArguments\n\nobject: The object aws_json_value you want to add a value to.\nkey: The key to add the aws_json_value at.\nvalue: The aws_json_value you want to add.\n\nReturns\n\nAWS_OP_SUCCESS if adding was successful. Will return AWS_OP_ERROR if the object passed is invalid or if the passed key is already in use in the object.\n\nPrototype\n\nint aws_json_value_add_to_object_c_str(struct aws_json_value *object, const char *key, struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_compare-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_compare","text":"aws_json_value_compare(a, b, is_case_sensitive)\n\nChecks whether two json values are equivalent.\n\nArguments\n\na: first value to compare.\nb: second value to compare.\nis_case_sensitive: case sensitive compare or not.\n\nReturns\n\nTrue is values are equal, false otherwise\n\nPrototype\n\nbool aws_json_value_compare(const struct aws_json_value *a, const struct aws_json_value *b, bool is_case_sensitive);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_destroy","text":"aws_json_value_destroy(value)\n\nRemoves the aws_json_value from memory. If the aws_json_value is a object or array, it will also destroy attached aws_json_values as well.\n\nFor example, if you called \"aws_json_array_add(b, a)\" to add an object \"a\" to an array \"b\", if you call \"aws_json_destroy(b)\" then it will also free \"a\" automatically. All children/attached aws_json_values are freed when the parent/root aws_json_value is destroyed.\n\nArguments\n\nvalue: The aws_json_value to destroy.\n\nPrototype\n\nvoid aws_json_value_destroy(struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_duplicate-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_duplicate","text":"aws_json_value_duplicate(value)\n\nDuplicates json value.\n\nArguments\n\nvalue: first value to compare.\n\nReturns\n\nduplicated value. NULL and last error set if value cannot be duplicated.\n\nPrototype\n\nstruct aws_json_value *aws_json_value_duplicate(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_get_boolean-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_get_boolean","text":"aws_json_value_get_boolean(value, output)\n\nGets the boolean of a boolean aws_json_value.\n\nArguments\n\nvalue: The boolean aws_json_value.\noutput: The boolean\n\nReturns\n\nAWS_OP_SUCCESS if the value is a boolean, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_json_value_get_boolean(const struct aws_json_value *value, bool *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_get_from_object-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_get_from_object","text":"aws_json_value_get_from_object(object, key)\n\nReturns the aws_json_value at the given key. Note: might be slower than c_str version due to internal copy\n\nArguments\n\nobject: The object aws_json_value you want to get the value from.\nkey: The key that the aws_json_value is at. Is case sensitive.\n\nReturns\n\nThe aws_json_value at the given key, otherwise NULL.\n\nPrototype\n\nstruct aws_json_value *aws_json_value_get_from_object(const struct aws_json_value *object, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_get_from_object_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_get_from_object_c_str","text":"aws_json_value_get_from_object_c_str(object, key)\n\nReturns the aws_json_value at the given key. Note: same as aws_json_value_get_from_object but with key as const char *. Prefer this method is you have a key thats already a valid char * as it is likely to be faster.\n\nArguments\n\nobject: The object aws_json_value you want to get the value from.\nkey: The key that the aws_json_value is at. Is case sensitive.\n\nReturns\n\nThe aws_json_value at the given key, otherwise NULL.\n\nPrototype\n\nstruct aws_json_value *aws_json_value_get_from_object_c_str(const struct aws_json_value *object, const char *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_get_number-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_get_number","text":"aws_json_value_get_number(value, output)\n\nGets the number of a number aws_json_value.\n\nArguments\n\nvalue: The number aws_json_value.\noutput: The number\n\nReturns\n\nAWS_OP_SUCCESS if the value is a number, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_json_value_get_number(const struct aws_json_value *value, double *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_get_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_get_string","text":"aws_json_value_get_string(value, output)\n\nGets the string of a string aws_json_value.\n\nArguments\n\nvalue: The string aws_json_value.\noutput: The string\n\nReturns\n\nAWS_OP_SUCCESS if the value is a string, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_json_value_get_string(const struct aws_json_value *value, struct aws_byte_cursor *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_has_key-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_has_key","text":"aws_json_value_has_key(object, key)\n\nChecks if there is a aws_json_value at the given key. Note: might be slower than c_str version due to internal copy\n\nArguments\n\nobject: The value aws_json_value you want to check a key in.\nkey: The key that you want to check. Is case sensitive.\n\nReturns\n\nTrue if a aws_json_value is found.\n\nPrototype\n\nbool aws_json_value_has_key(const struct aws_json_value *object, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_has_key_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_has_key_c_str","text":"aws_json_value_has_key_c_str(object, key)\n\nChecks if there is a aws_json_value at the given key. Note: same as aws_json_value_has_key but with key as const char *. Prefer this method is you have a key thats already a valid char * as it is likely to be faster.\n\nArguments\n\nobject: The value aws_json_value you want to check a key in.\nkey: The key that you want to check. Is case sensitive.\n\nReturns\n\nTrue if a aws_json_value is found.\n\nPrototype\n\nbool aws_json_value_has_key_c_str(const struct aws_json_value *object, const char *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_is_array-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_is_array","text":"aws_json_value_is_array(value)\n\nChecks if the aws_json_value is a array.\n\nArguments\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a array aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_array(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_is_boolean-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_is_boolean","text":"aws_json_value_is_boolean(value)\n\nChecks if the aws_json_value is a boolean.\n\nArguments\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a boolean aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_boolean(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_is_null-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_is_null","text":"aws_json_value_is_null(value)\n\nChecks if the aws_json_value is a null aws_json_value.\n\nArguments\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a null aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_null(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_is_number-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_is_number","text":"aws_json_value_is_number(value)\n\nChecks if the aws_json_value is a number.\n\nArguments\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a number aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_number(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_is_object-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_is_object","text":"aws_json_value_is_object(value)\n\nChecks if the aws_json_value is a object aws_json_value.\n\nArguments\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a object aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_object(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_is_string-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_is_string","text":"aws_json_value_is_string(value)\n\nChecks if the aws_json_value is a string.\n\nArguments\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a string aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_string(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_array-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_array","text":"aws_json_value_new_array(allocator)\n\nCreates a new array aws_json_value and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value. Deleting this array will also destroy any aws_json_values it contains.\n\nArguments\n\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new array aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_array(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_boolean-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_boolean","text":"aws_json_value_new_boolean(allocator, boolean)\n\nCreates a new boolean aws_json_value with the given boolean and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nArguments\n\nboolean: The boolean you want to store in the aws_json_value\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new boolean aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_boolean(struct aws_allocator *allocator, bool boolean);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_from_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_from_string","text":"aws_json_value_new_from_string(allocator, string)\n\nParses the JSON string and returns a aws_json_value containing the root of the JSON.\n\nArguments\n\nallocator: The allocator used to create the value\nstring: The string containing the JSON.\n\nReturns\n\nThe root aws_json_value of the JSON.\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_from_string(struct aws_allocator *allocator, struct aws_byte_cursor string);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_null-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_null","text":"aws_json_value_new_null(allocator)\n\nCreates a new null aws_json_value and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nArguments\n\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new null aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_null(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_number-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_number","text":"aws_json_value_new_number(allocator, number)\n\nCreates a new number aws_json_value with the given number and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nArguments\n\nnumber: The number you want to store in the aws_json_value\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new number aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_number(struct aws_allocator *allocator, double number);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_object-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_object","text":"aws_json_value_new_object(allocator)\n\nCreates a new object aws_json_value and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value. Deleting this object will also destroy any aws_json_values it contains.\n\nArguments\n\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new object aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_object(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_string","text":"aws_json_value_new_string(allocator, string)\n\nCreates a new string aws_json_value with the given string and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value. Note: might be slower than c_str version due to internal copy\n\nArguments\n\nstring: A byte cursor you want to store in the aws_json_value\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new string aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_string(struct aws_allocator *allocator, struct aws_byte_cursor string);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_new_string_from_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_new_string_from_c_str","text":"aws_json_value_new_string_from_c_str(allocator, string)\n\nCreates a new string aws_json_value with the given string and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nArguments\n\nstring: c string pointer you want to store in the aws_json_value\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new string aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_string_from_c_str(struct aws_allocator *allocator, const char *string);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_remove_array_element-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_remove_array_element","text":"aws_json_value_remove_array_element(array, index)\n\nRemoves the aws_json_value at the given index in the array aws_json_value.\n\nArguments\n\narray: The array aws_json_value.\nindex: The index containing the aws_json_value you want to remove.\n\nReturns\n\nAWS_OP_SUCCESS if the aws_json_value at the index was removed. Will return AWS_OP_ERR if the array passed is invalid or if the index passed is out of range.\n\nPrototype\n\nint aws_json_value_remove_array_element(struct aws_json_value *array, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_remove_from_object-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_remove_from_object","text":"aws_json_value_remove_from_object(object, key)\n\nRemoves the aws_json_value at the given key. Note: might be slower than c_str version due to internal copy\n\nArguments\n\nobject: The object aws_json_value you want to remove a aws_json_value in.\nkey: The key that the aws_json_value is at. Is case sensitive.\n\nReturns\n\nAWS_OP_SUCCESS if the aws_json_value was removed. Will return AWS_OP_ERR if the object passed is invalid or if the value at the key cannot be found.\n\nPrototype\n\nint aws_json_value_remove_from_object(struct aws_json_value *object, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_json_value_remove_from_object_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_json_value_remove_from_object_c_str","text":"aws_json_value_remove_from_object_c_str(object, key)\n\nRemoves the aws_json_value at the given key. Note: same as aws_json_value_remove_from_object but with key as const char *. Prefer this method is you have a key thats already a valid char * as it is likely to be faster.\n\nArguments\n\nobject: The object aws_json_value you want to remove a aws_json_value in.\nkey: The key that the aws_json_value is at. Is case sensitive.\n\nReturns\n\nAWS_OP_SUCCESS if the aws_json_value was removed. Will return AWS_OP_ERR if the object passed is invalid or if the value at the key cannot be found.\n\nPrototype\n\nint aws_json_value_remove_from_object_c_str(struct aws_json_value *object, const char *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_last_error-Tuple{}","page":"Home","title":"LibAwsCommon.aws_last_error","text":"aws_last_error()\n\nReturns the latest error code on the current thread, or 0 if none have occurred.\n\nPrototype\n\nint aws_last_error(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_clean_up","text":"aws_linked_hash_table_clean_up(table)\n\nCleans up the table. Elements in the table will be evicted and cleanup callbacks will be invoked.\n\nPrototype\n\nvoid aws_linked_hash_table_clean_up(struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_clear-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_clear","text":"aws_linked_hash_table_clear(table)\n\nClears all items from the table.\n\nPrototype\n\nvoid aws_linked_hash_table_clear(struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_find","text":"aws_linked_hash_table_find(table, key, p_value)\n\nFinds element in the table by key. If found, AWS_OP_SUCCESS will be returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\nIf any errors occur AWS_OP_ERR will be returned.\n\nPrototype\n\nint aws_linked_hash_table_find(struct aws_linked_hash_table *table, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_find_and_move_to_back-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_find_and_move_to_back","text":"aws_linked_hash_table_find_and_move_to_back(table, key, p_value)\n\nFinds element in the table by key. If found, AWS_OP_SUCCESS will be returned and the item will be moved to the back of the list. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\nNote: this will change the order of elements\n\nPrototype\n\nint aws_linked_hash_table_find_and_move_to_back(struct aws_linked_hash_table *table, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_get_element_count-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_get_element_count","text":"aws_linked_hash_table_get_element_count(table)\n\nreturns number of elements in the table.\n\nPrototype\n\nsize_t aws_linked_hash_table_get_element_count(const struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_get_iteration_list-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_get_iteration_list","text":"aws_linked_hash_table_get_iteration_list(table)\n\nreturns the underlying linked list for iteration.\n\nThe returned list has nodes of the type: aws_linked_hash_table_node. Use AWS_CONTAINER_OF for access to the element.\n\nPrototype\n\nconst struct aws_linked_list *aws_linked_hash_table_get_iteration_list(const struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_init-NTuple{7, Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_init","text":"aws_linked_hash_table_init(table, allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, initial_item_count)\n\nInitializes the table. Sets up the underlying hash table and linked list. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.\n\nPrototype\n\nint aws_linked_hash_table_init( struct aws_linked_hash_table *table, struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t initial_item_count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_move_node_to_end_of_list-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_move_node_to_end_of_list","text":"aws_linked_hash_table_move_node_to_end_of_list(table, node)\n\nMove the aws_linked_hash_table_node to the end of the list.\n\nNote: this will change the order of elements\n\nPrototype\n\nvoid aws_linked_hash_table_move_node_to_end_of_list( struct aws_linked_hash_table *table, struct aws_linked_hash_table_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_put-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_put","text":"aws_linked_hash_table_put(table, key, p_value)\n\nPuts p_value at key. If an element is already stored at key it will be replaced.\n\nPrototype\n\nint aws_linked_hash_table_put(struct aws_linked_hash_table *table, const void *key, void *p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_hash_table_remove-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_hash_table_remove","text":"aws_linked_hash_table_remove(table, key)\n\nRemoves item at key from the table.\n\nPrototype\n\nint aws_linked_hash_table_remove(struct aws_linked_hash_table *table, const void *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_back-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_back","text":"aws_linked_list_back(list)\n\nReturns the element in the back of the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_back(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_begin-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_begin","text":"aws_linked_list_begin(list)\n\nReturns an iteration pointer for the first element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_begin(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_empty-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_empty","text":"aws_linked_list_empty(list)\n\nTests if the list is empty.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_empty(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_end-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_end","text":"aws_linked_list_end(list)\n\nReturns an iteration pointer for one past the last element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL const struct aws_linked_list_node *aws_linked_list_end(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_front-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_front","text":"aws_linked_list_front(list)\n\nReturns the element in the front of the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_front(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_init-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_init","text":"aws_linked_list_init(list)\n\nInitializes the list. List will be empty after this call.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_init(struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_insert_after-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_insert_after","text":"aws_linked_list_insert_after(after, to_add)\n\nInserts to_add immediately after after.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_insert_after( struct aws_linked_list_node *after, struct aws_linked_list_node *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_insert_before-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_insert_before","text":"aws_linked_list_insert_before(before, to_add)\n\nInserts to_add immediately before before.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_insert_before( struct aws_linked_list_node *before, struct aws_linked_list_node *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_is_valid","text":"aws_linked_list_is_valid(list)\n\nChecks that a linked list is valid.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_is_valid(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_is_valid_deep-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_is_valid_deep","text":"aws_linked_list_is_valid_deep(list)\n\nChecks that a linked list satisfies double linked list connectivity constraints. This check is O(n) as it traverses the whole linked list to ensure that tail is reachable from head (and vice versa) and that every connection is bidirectional.\n\nNote: This check cannot go into an infinite loop, because we ensure that the connection to the next node is bidirectional. Therefore, if a node's [a] a.next is a previous node [b] in the list, b.prev != &a and so this check would fail, thus terminating the loop.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_is_valid_deep(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_move_all_back-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_move_all_back","text":"aws_linked_list_move_all_back(dst, src)\n\nRemove all nodes from one list, and add them to the back of another.\n\nExample: if dst={1,2} and src={3,4}, they become dst={1,2,3,4} and src={}\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_move_all_back( struct aws_linked_list *AWS_RESTRICT dst, struct aws_linked_list *AWS_RESTRICT src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_move_all_front-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_move_all_front","text":"aws_linked_list_move_all_front(dst, src)\n\nRemove all nodes from one list, and add them to the front of another.\n\nExample: if dst={2,1} and src={4,3}, they become dst={4,3,2,1} and src={}\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_move_all_front( struct aws_linked_list *AWS_RESTRICT dst, struct aws_linked_list *AWS_RESTRICT src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_next-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_next","text":"aws_linked_list_next(node)\n\nReturns the next element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_next(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_node_is_in_list-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_node_is_in_list","text":"aws_linked_list_node_is_in_list(node)\n\nReturns true if the node is currently in a list, false otherwise.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_node_is_in_list(struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_node_next_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_node_next_is_valid","text":"aws_linked_list_node_next_is_valid(node)\n\nChecks that the prev of the next pointer of a node points to the node. As this checks whether the [next] connection of a node is bidirectional, it returns false if used for the list tail.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_node_next_is_valid(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_node_prev_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_node_prev_is_valid","text":"aws_linked_list_node_prev_is_valid(node)\n\nChecks that the next of the prev pointer of a node points to the node. Similarly to the above, this returns false if used for the head of a list.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_node_prev_is_valid(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_node_reset-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_node_reset","text":"aws_linked_list_node_reset(node)\n\nSet node's next and prev pointers to NULL.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_node_reset(struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_pop_back-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_pop_back","text":"aws_linked_list_pop_back(list)\n\nReturns the element in the back of the list and removes it\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_pop_back(struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_pop_front-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_pop_front","text":"aws_linked_list_pop_front(list)\n\nReturns the element in the front of the list and removes it\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_pop_front(struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_prev-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_prev","text":"aws_linked_list_prev(node)\n\nReturns the previous element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_prev(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_push_back-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_push_back","text":"aws_linked_list_push_back(list, node)\n\nAppend new_node.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_push_back(struct aws_linked_list *list, struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_push_front-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_push_front","text":"aws_linked_list_push_front(list, node)\n\nPrepend new_node.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_push_front(struct aws_linked_list *list, struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_rbegin-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_rbegin","text":"aws_linked_list_rbegin(list)\n\nReturns a pointer for the last element in the list. Used to begin iterating the list in reverse. Ex: for (i = aws_linked_list_rbegin(list); i != aws_linked_list_rend(list); i = aws_linked_list_prev(i)) {...}\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_rbegin(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_remove-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_remove","text":"aws_linked_list_remove(node)\n\nRemoves the specified node from the list (prev/next point to each other) and returns the next node in the list.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_remove(struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_rend-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_rend","text":"aws_linked_list_rend(list)\n\nReturns the pointer to one before the first element in the list. Used to end iterating the list in reverse.\n\nPrototype\n\nAWS_STATIC_IMPL const struct aws_linked_list_node *aws_linked_list_rend(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_swap_contents-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_swap_contents","text":"aws_linked_list_swap_contents(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_swap_contents( struct aws_linked_list *AWS_RESTRICT a, struct aws_linked_list *AWS_RESTRICT b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_linked_list_swap_nodes-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_linked_list_swap_nodes","text":"aws_linked_list_swap_nodes(a, b)\n\nSwaps the order two nodes in the linked list.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_swap_nodes(struct aws_linked_list_node *a, struct aws_linked_list_node *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_localtime-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_localtime","text":"aws_localtime(time, t)\n\nCross platform friendly version of localtime_r\n\nPrototype\n\nvoid aws_localtime(time_t time, struct tm *t);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_channel_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_log_channel_clean_up","text":"aws_log_channel_clean_up(channel)\n\nChannel cleanup function\n\nPrototype\n\nvoid aws_log_channel_clean_up(struct aws_log_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_channel_init_background-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_log_channel_init_background","text":"aws_log_channel_init_background(channel, allocator, writer)\n\nSimple channel that sends log lines to a background thread.\n\nThe passed in log writer is not an ownership transfer. The log channel does not clean up the writer.\n\nPrototype\n\nint aws_log_channel_init_background( struct aws_log_channel *channel, struct aws_allocator *allocator, struct aws_log_writer *writer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_channel_init_foreground-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_log_channel_init_foreground","text":"aws_log_channel_init_foreground(channel, allocator, writer)\n\nSimple channel that results in log lines being written in the same thread they were generated in.\n\nThe passed in log writer is not an ownership transfer. The log channel does not clean up the writer.\n\nPrototype\n\nint aws_log_channel_init_foreground( struct aws_log_channel *channel, struct aws_allocator *allocator, struct aws_log_writer *writer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_formatter_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_log_formatter_clean_up","text":"aws_log_formatter_clean_up(formatter)\n\nCleans up a log formatter (minus the base structure memory) by calling the formatter's clean_up function via the vtable.\n\nPrototype\n\nvoid aws_log_formatter_clean_up(struct aws_log_formatter *formatter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_formatter_init_default-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_log_formatter_init_default","text":"aws_log_formatter_init_default(formatter, allocator, options)\n\nInitializes the default log formatter which outputs lines in the format:\n\n[<LogLevel>] [<Timestamp>] [<ThreadId>] - <User content>\n\nPrototype\n\nint aws_log_formatter_init_default( struct aws_log_formatter *formatter, struct aws_allocator *allocator, struct aws_log_formatter_standard_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_level_to_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_log_level_to_string","text":"aws_log_level_to_string(log_level, level_string)\n\nConverts a log level to a c-string constant. Intended primarily to support building log lines that include the level in them, i.e.\n\n[ERROR] 10:34:54.642 01-31-19 - Json parse error....\n\nPrototype\n\nint aws_log_level_to_string(enum aws_log_level log_level, const char **level_string);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_subject_name-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_log_subject_name","text":"aws_log_subject_name(subject)\n\nGet subject name from log subject.\n\nPrototype\n\nconst char *aws_log_subject_name(aws_log_subject_t subject);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_writer_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_log_writer_clean_up","text":"aws_log_writer_clean_up(writer)\n\nFrees all resources used by a log writer with the exception of the base structure memory\n\nPrototype\n\nvoid aws_log_writer_clean_up(struct aws_log_writer *writer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_writer_init_file-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_log_writer_init_file","text":"aws_log_writer_init_file(writer, allocator, options)\n\nInitialize a log writer that sends log lines to a file. Uses C library IO.\n\nPrototype\n\nint aws_log_writer_init_file( struct aws_log_writer *writer, struct aws_allocator *allocator, struct aws_log_writer_file_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_writer_init_stderr-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_log_writer_init_stderr","text":"aws_log_writer_init_stderr(writer, allocator)\n\nInitialize a log writer that sends log lines to stderr. Uses C library IO.\n\nPrototype\n\nint aws_log_writer_init_stderr(struct aws_log_writer *writer, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_log_writer_init_stdout-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_log_writer_init_stdout","text":"aws_log_writer_init_stdout(writer, allocator)\n\nInitialize a log writer that sends log lines to stdout. Uses C library IO.\n\nPrototype\n\nint aws_log_writer_init_stdout(struct aws_log_writer *writer, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_logger_clean_up","text":"aws_logger_clean_up(logger)\n\nCleans up all resources used by the logger; simply invokes the clean_up v-function\n\nPrototype\n\nvoid aws_logger_clean_up(struct aws_logger *logger);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_get-Tuple{}","page":"Home","title":"LibAwsCommon.aws_logger_get","text":"aws_logger_get()\n\nGets the aws logger used globally across the process.\n\nPrototype\n\nstruct aws_logger *aws_logger_get(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_get_conditional-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_logger_get_conditional","text":"aws_logger_get_conditional(subject, level)\n\nGets the aws logger used globally across the process if the logging level is at least the inputted level.\n\nArguments\n\nsubject: log subject to perform the level check versus, not currently used\nlevel: logging level to check against in order to return the logger\n\nReturns\n\nthe current logger if the current logging level is at or more detailed then the supplied logging level\n\nPrototype\n\nstruct aws_logger *aws_logger_get_conditional(aws_log_subject_t subject, enum aws_log_level level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_init_from_external-NTuple{6, Any}","page":"Home","title":"LibAwsCommon.aws_logger_init_from_external","text":"aws_logger_init_from_external(logger, allocator, formatter, channel, writer, level)\n\nInitializes a pipeline logger from components that have already been initialized. This is not an ownership transfer. After the pipeline logger is cleaned up, the components will have to manually be cleaned up by the user.\n\nPrototype\n\nint aws_logger_init_from_external( struct aws_logger *logger, struct aws_allocator *allocator, struct aws_log_formatter *formatter, struct aws_log_channel *channel, struct aws_log_writer *writer, enum aws_log_level level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_init_noalloc-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_logger_init_noalloc","text":"aws_logger_init_noalloc(logger, allocator, options)\n\nInitializes a logger that does not perform any allocation during logging. Log lines larger than the internal constant are truncated. Formatting matches the standard logger. Used for memory tracing logging. If no file or filename is set in the aws_logger_standard_options, then it will use stderr.\n\nPrototype\n\nint aws_logger_init_noalloc( struct aws_logger *logger, struct aws_allocator *allocator, struct aws_logger_standard_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_init_standard-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_logger_init_standard","text":"aws_logger_init_standard(logger, allocator, options)\n\nInitializes a pipeline logger that is built from the default formatter, a background thread-based channel, and a file writer. The default logger in almost all circumstances.\n\nPrototype\n\nint aws_logger_init_standard( struct aws_logger *logger, struct aws_allocator *allocator, struct aws_logger_standard_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_set-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_logger_set","text":"aws_logger_set(logger)\n\nSets the aws logger used globally across the process. Not thread-safe. Must only be called once.\n\nPrototype\n\nvoid aws_logger_set(struct aws_logger *logger);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_logger_set_log_level-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_logger_set_log_level","text":"aws_logger_set_log_level(logger, level)\n\nSets the current logging level for the logger. Loggers are not require to support this.\n\nArguments\n\nlogger: logger to set the log level for\nlevel: new log level for the logger\n\nReturns\n\nAWS_OP_SUCCESS if the level was successfully set, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_logger_set_log_level(struct aws_logger *logger, enum aws_log_level level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_lookup_table_hex_to_num_get-Tuple{}","page":"Home","title":"LibAwsCommon.aws_lookup_table_hex_to_num_get","text":"aws_lookup_table_hex_to_num_get()\n\nReturns lookup table to go from ASCII/UTF-8 hex character to a number (0-15). Non-hex characters map to 255. Valid examples: '0' -> 0 'F' -> 15 'f' -> 15 Invalid examples: ' ' -> 255 'Z' -> 255 '\\0' -> 255\n\nPrototype\n\nconst uint8_t *aws_lookup_table_hex_to_num_get(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_lookup_table_to_lower_get-Tuple{}","page":"Home","title":"LibAwsCommon.aws_lookup_table_to_lower_get","text":"aws_lookup_table_to_lower_get()\n\nReturns a lookup table for bytes that is the identity transformation with the exception of uppercase ascii characters getting replaced with lowercase characters. Used in caseless comparisons.\n\nPrototype\n\nconst uint8_t *aws_lookup_table_to_lower_get(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_lru_cache_get_mru_element-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_lru_cache_get_mru_element","text":"aws_lru_cache_get_mru_element(cache)\n\nAccesses the most-recently-used element and returns its value.\n\nPrototype\n\nvoid *aws_lru_cache_get_mru_element(const struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_lru_cache_use_lru_element-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_lru_cache_use_lru_element","text":"aws_lru_cache_use_lru_element(cache)\n\nAccesses the least-recently-used element, sets it to most-recently-used element, and returns the value.\n\nPrototype\n\nvoid *aws_lru_cache_use_lru_element(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_double-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_double","text":"aws_max_double(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL double aws_max_double(double a, double b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_float-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_float","text":"aws_max_float(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL float aws_max_float(float a, float b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_i16-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_i16","text":"aws_max_i16(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int16_t aws_max_i16(int16_t a, int16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_i32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_i32","text":"aws_max_i32(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int32_t aws_max_i32(int32_t a, int32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_i64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_i64","text":"aws_max_i64(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int64_t aws_max_i64(int64_t a, int64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_i8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_i8","text":"aws_max_i8(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int8_t aws_max_i8(int8_t a, int8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_int-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_int","text":"aws_max_int(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_max_int(int a, int b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_size-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_size","text":"aws_max_size(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_max_size(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_u16-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_u16","text":"aws_max_u16(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_max_u16(uint16_t a, uint16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_u32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_u32","text":"aws_max_u32(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_max_u32(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_u64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_u64","text":"aws_max_u64(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_max_u64(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_max_u8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_max_u8","text":"aws_max_u8(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint8_t aws_max_u8(uint8_t a, uint8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_acquire-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_mem_acquire","text":"aws_mem_acquire(allocator, size)\n\nReturns at least size of memory ready for usage. In versions v0.6.8 and prior, this function was allowed to return NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a GC etc...before returning.\n\nPrototype\n\nvoid *aws_mem_acquire(struct aws_allocator *allocator, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_calloc-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_mem_calloc","text":"aws_mem_calloc(allocator, num, size)\n\nAllocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits to zero. In versions v0.6.8 and prior, this function was allowed to return NULL. In later versions, if allocator->mem_calloc() returns NULL, this function will assert and exit. To handle conditions where OOM is not a fatal error, allocator->mem_calloc() is responsible for finding/reclaiming/running a GC etc...before returning.\n\nPrototype\n\nvoid *aws_mem_calloc(struct aws_allocator *allocator, size_t num, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_realloc-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_mem_realloc","text":"aws_mem_realloc(allocator, ptr, oldsize, newsize)\n\nAttempts to adjust the size of the pointed-to memory buffer from oldsize to newsize. The pointer (*ptr) may be changed if the memory needs to be reallocated.\n\nIn versions v0.6.8 and prior, this function was allowed to return NULL. In later versions, if allocator->mem_realloc() returns NULL, this function will assert and exit. To handle conditions where OOM is not a fatal error, allocator->mem_realloc() is responsible for finding/reclaiming/running a GC etc...before returning.\n\nPrototype\n\nint aws_mem_realloc(struct aws_allocator *allocator, void **ptr, size_t oldsize, size_t newsize);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_release-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_mem_release","text":"aws_mem_release(allocator, ptr)\n\nReleases ptr back to whatever allocated it. Nothing happens if ptr is NULL.\n\nPrototype\n\nvoid aws_mem_release(struct aws_allocator *allocator, void *ptr);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_tracer_bytes-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mem_tracer_bytes","text":"aws_mem_tracer_bytes(trace_allocator)\n\nReturns the current number of bytes in outstanding allocations\n\nPrototype\n\nsize_t aws_mem_tracer_bytes(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_tracer_count-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mem_tracer_count","text":"aws_mem_tracer_count(trace_allocator)\n\nReturns the current number of outstanding allocations\n\nPrototype\n\nsize_t aws_mem_tracer_count(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_tracer_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mem_tracer_destroy","text":"aws_mem_tracer_destroy(trace_allocator)\n\nUnwraps the traced allocator and cleans up the tracer. Returns the original allocator\n\nPrototype\n\nstruct aws_allocator *aws_mem_tracer_destroy(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_tracer_dump-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mem_tracer_dump","text":"aws_mem_tracer_dump(trace_allocator)\n\nIf there are outstanding allocations, dumps them to log, along with any information gathered based on the trace level set when aws_mem_trace() was called. Should be passed the tracer allocator returned from aws_mem_trace().\n\nPrototype\n\nvoid aws_mem_tracer_dump(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mem_tracer_new-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_mem_tracer_new","text":"aws_mem_tracer_new(allocator, deprecated, level, frames_per_stack)\n\nWraps an allocator and tracks all external allocations. If aws_mem_trace_dump() is called and there are still allocations active, they will be reported to the aws_logger at TRACE level. allocator - The allocator to wrap deprecated - Deprecated arg, ignored. level - The level to track allocations at frames_per_stack is how many frames to store per callstack if AWS_MEMTRACE_STACKS is in use, otherwise it is ignored. 8 tends to be a pretty good number balancing storage space vs useful stacks. Returns the tracer allocator, which should be used for all allocations that should be tracked.\n\nPrototype\n\nstruct aws_allocator *aws_mem_tracer_new( struct aws_allocator *allocator, struct aws_allocator *deprecated, enum aws_mem_trace_level level, size_t frames_per_stack);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_double-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_double","text":"aws_min_double(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL double aws_min_double(double a, double b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_float-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_float","text":"aws_min_float(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL float aws_min_float(float a, float b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_i16-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_i16","text":"aws_min_i16(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int16_t aws_min_i16(int16_t a, int16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_i32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_i32","text":"aws_min_i32(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int32_t aws_min_i32(int32_t a, int32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_i64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_i64","text":"aws_min_i64(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int64_t aws_min_i64(int64_t a, int64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_i8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_i8","text":"aws_min_i8(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int8_t aws_min_i8(int8_t a, int8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_int-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_int","text":"aws_min_int(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_min_int(int a, int b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_size-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_size","text":"aws_min_size(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_min_size(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_u16-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_u16","text":"aws_min_u16(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_min_u16(uint16_t a, uint16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_u32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_u32","text":"aws_min_u32(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_min_u32(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_u64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_u64","text":"aws_min_u64(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_min_u64(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_min_u8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_min_u8","text":"aws_min_u8(a, b)\n\nDocumentation not found.\n\nPrototype\n\nAWS_STATIC_IMPL uint8_t aws_min_u8(uint8_t a, uint8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mul_size_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_mul_size_checked","text":"aws_mul_size_checked(a, b, r)\n\nMultiplies a * b and returns the result in *r. If the result overflows, returns AWS_OP_ERR; otherwise returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_mul_size_checked(size_t a, size_t b, size_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mul_size_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_mul_size_saturating","text":"aws_mul_size_saturating(a, b)\n\nMultiplies a * b. If the result overflows, returns SIZE_MAX.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_mul_size_saturating(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mul_u32_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_mul_u32_checked","text":"aws_mul_u32_checked(a, b, r)\n\nIf a * b overflows, returns AWS_OP_ERR; otherwise multiplies a * b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_mul_u32_checked(uint32_t a, uint32_t b, uint32_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mul_u32_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_mul_u32_saturating","text":"aws_mul_u32_saturating(a, b)\n\nMultiplies a * b. If the result overflows, returns 2^32 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_mul_u32_saturating(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mul_u64_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_mul_u64_checked","text":"aws_mul_u64_checked(a, b, r)\n\nIf a * b overflows, returns AWS_OP_ERR; otherwise multiplies a * b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_mul_u64_checked(uint64_t a, uint64_t b, uint64_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mul_u64_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_mul_u64_saturating","text":"aws_mul_u64_saturating(a, b)\n\nMultiplies a * b. If the result overflows, returns 2^64 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_mul_u64_saturating(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mutex_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mutex_clean_up","text":"aws_mutex_clean_up(mutex)\n\nCleans up internal resources.\n\nPrototype\n\nvoid aws_mutex_clean_up(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mutex_init-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mutex_init","text":"aws_mutex_init(mutex)\n\nInitializes a new platform instance of mutex.\n\nPrototype\n\nint aws_mutex_init(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mutex_lock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mutex_lock","text":"aws_mutex_lock(mutex)\n\nBlocks until it acquires the lock. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n\nPrototype\n\nint aws_mutex_lock(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mutex_try_lock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mutex_try_lock","text":"aws_mutex_try_lock(mutex)\n\nAttempts to acquire the lock but returns immediately if it can not. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be. Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]\n\nPrototype\n\nint aws_mutex_try_lock(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_mutex_unlock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_mutex_unlock","text":"aws_mutex_unlock(mutex)\n\nReleases the lock.\n\nPrototype\n\nint aws_mutex_unlock(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_normalize_directory_separator-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_normalize_directory_separator","text":"aws_normalize_directory_separator(path)\n\nNormalizes the path by replacing any directory separator with the local platform's directory separator.\n\nArguments\n\npath: path to normalize. Must be writeable.\n\nPrototype\n\nvoid aws_normalize_directory_separator(struct aws_byte_buf *path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ntoh16-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ntoh16","text":"aws_ntoh16(x)\n\nConvert 16 bit integer from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_ntoh16(uint16_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ntoh32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ntoh32","text":"aws_ntoh32(x)\n\nConvert 32 bit integer from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_ntoh32(uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ntoh64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ntoh64","text":"aws_ntoh64(x)\n\nConvert 64 bit integer from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_ntoh64(uint64_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ntohf32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ntohf32","text":"aws_ntohf32(x)\n\nConvert 32 bit float from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL float aws_ntohf32(float x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ntohf64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ntohf64","text":"aws_ntohf64(x)\n\nConvert 32 bit float from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL double aws_ntohf64(double x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_path_exists-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_path_exists","text":"aws_path_exists(path)\n\nReturns true if a file or path exists, otherwise, false.\n\nPrototype\n\nbool aws_path_exists(const struct aws_string *path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_backpointer_index_valid-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_backpointer_index_valid","text":"aws_priority_queue_backpointer_index_valid(queue, index)\n\nChecks that the backpointer at a specific index of the queue is NULL or points to a correctly allocated aws_priority_queue_node.\n\nPrototype\n\nbool aws_priority_queue_backpointer_index_valid(const struct aws_priority_queue *const queue, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_backpointers_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_backpointers_valid","text":"aws_priority_queue_backpointers_valid(queue)\n\nChecks that the backpointers of the priority queue satisfy validity constraints.\n\nPrototype\n\nbool aws_priority_queue_backpointers_valid(const struct aws_priority_queue *const queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_backpointers_valid_deep-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_backpointers_valid_deep","text":"aws_priority_queue_backpointers_valid_deep(queue)\n\nChecks that the backpointers of the priority queue are either NULL or correctly allocated to point at aws_priority_queue_nodes. This check is O(n), as it accesses every backpointer in a loop, and thus shouldn't be used carelessly.\n\nPrototype\n\nbool aws_priority_queue_backpointers_valid_deep(const struct aws_priority_queue *const queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_capacity-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_capacity","text":"aws_priority_queue_capacity(queue)\n\nCurrent allocated capacity for the queue, in dynamic mode this grows over time, in static mode, this will never change.\n\nPrototype\n\nsize_t aws_priority_queue_capacity(const struct aws_priority_queue *queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_clean_up","text":"aws_priority_queue_clean_up(queue)\n\nCleans up any internally allocated memory and resets the struct for reuse or deletion.\n\nPrototype\n\nvoid aws_priority_queue_clean_up(struct aws_priority_queue *queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_clear-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_clear","text":"aws_priority_queue_clear(queue)\n\nRemoves all elements from the queue, but does not free internal memory.\n\nPrototype\n\nvoid aws_priority_queue_clear(struct aws_priority_queue *queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_init_dynamic-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_init_dynamic","text":"aws_priority_queue_init_dynamic(queue, alloc, default_size, item_size, pred)\n\nInitializes a priority queue struct for use. This mode will grow memory automatically (exponential model) Default size is the inital size of the queue item_size is the size of each element in bytes. Mixing items types is not supported by this API. pred is the function that will be used to determine priority.\n\nPrototype\n\nint aws_priority_queue_init_dynamic( struct aws_priority_queue *queue, struct aws_allocator *alloc, size_t default_size, size_t item_size, aws_priority_queue_compare_fn *pred);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_init_static-NTuple{5, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_init_static","text":"aws_priority_queue_init_static(queue, heap, item_count, item_size, pred)\n\nInitializes a priority queue struct for use. This mode will not allocate any additional memory. When the heap fills new enqueue operations will fail with AWS_ERROR_PRIORITY_QUEUE_FULL.\n\nHeaps initialized using this call do not support the aws_priority_queue_push_ref call with a non-NULL backpointer parameter.\n\nheap is the raw memory allocated for this priority_queue item_count is the maximum number of elements the raw heap can contain item_size is the size of each element in bytes. Mixing items types is not supported by this API. pred is the function that will be used to determine priority.\n\nPrototype\n\nvoid aws_priority_queue_init_static( struct aws_priority_queue *queue, void *heap, size_t item_count, size_t item_size, aws_priority_queue_compare_fn *pred);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_is_valid","text":"aws_priority_queue_is_valid(queue)\n\nSet of properties of a valid aws_priority_queue.\n\nPrototype\n\nbool aws_priority_queue_is_valid(const struct aws_priority_queue *const queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_node_init-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_node_init","text":"aws_priority_queue_node_init(node)\n\nInitializes a queue node to a default value that indicates the node is not in the queue.\n\nArguments\n\nnode: priority queue node to initialize with a default value\n\nPrototype\n\nvoid aws_priority_queue_node_init(struct aws_priority_queue_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_node_is_in_queue-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_node_is_in_queue","text":"aws_priority_queue_node_is_in_queue(node)\n\nChecks if a priority queue node is currently in a priority queue.\n\nArguments\n\nnode: priority queue node to check usage for\n\nReturns\n\ntrue if the node is in a queue, false otherwise\n\nPrototype\n\nbool aws_priority_queue_node_is_in_queue(const struct aws_priority_queue_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_pop-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_pop","text":"aws_priority_queue_pop(queue, item)\n\nCopies the element of the highest priority, and removes it from the queue.. Complexity: O(log(n)). If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised.\n\nPrototype\n\nint aws_priority_queue_pop(struct aws_priority_queue *queue, void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_push-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_push","text":"aws_priority_queue_push(queue, item)\n\nCopies item into the queue and places it in the proper priority order. Complexity: O(log(n)).\n\nPrototype\n\nint aws_priority_queue_push(struct aws_priority_queue *queue, void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_push_ref-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_push_ref","text":"aws_priority_queue_push_ref(queue, item, backpointer)\n\nCopies item into the queue and places it in the proper priority order. Complexity: O(log(n)).\n\nIf the backpointer parameter is non-null, the heap will continually update the pointed-to field with information needed to remove the node later on. *backpointer must remain valid until the node is removed from the heap, and may be updated on any mutating operation on the priority queue.\n\nIf the node is removed, the backpointer will be set to a sentinel value that indicates that the node has already been removed. It is safe (and a no-op) to call aws_priority_queue_remove with such a sentinel value.\n\nPrototype\n\nint aws_priority_queue_push_ref( struct aws_priority_queue *queue, void *item, struct aws_priority_queue_node *backpointer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_remove-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_remove","text":"aws_priority_queue_remove(queue, item, node)\n\nRemoves a specific node from the priority queue. Complexity: O(log(n)) After removing a node (using either _remove or _pop), the backpointer set at push_ref time is set to a sentinel value. If this sentinel value is passed to aws_priority_queue_remove, AWS_ERROR_PRIORITY_QUEUE_BAD_NODE will be raised. Note, however, that passing uninitialized aws_priority_queue_nodes, or ones from different priority queues, results in undefined behavior.\n\nPrototype\n\nint aws_priority_queue_remove(struct aws_priority_queue *queue, void *item, const struct aws_priority_queue_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_size-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_size","text":"aws_priority_queue_size(queue)\n\nCurrent number of elements in the queue\n\nPrototype\n\nsize_t aws_priority_queue_size(const struct aws_priority_queue *queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_priority_queue_top-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_priority_queue_top","text":"aws_priority_queue_top(queue, item)\n\nObtains a pointer to the element of the highest priority. Complexity: constant time. If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised.\n\nPrototype\n\nint aws_priority_queue_top(const struct aws_priority_queue *queue, void **item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ptr_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_ptr_eq","text":"aws_ptr_eq(a, b)\n\nEquality function which compares pointer equality.\n\nPrototype\n\nbool aws_ptr_eq(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_query_string_next_param-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_query_string_next_param","text":"aws_query_string_next_param(query_string, param)\n\nFor iterating over the params in the query string. param is an in/out argument used to track progress, it MUST be zeroed out to start. If true is returned, param contains the value of the next param. If false is returned, there are no further params.\n\nEdge cases: 1) Entries without '=' sign are treated as having a key and no value. Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\nBlank entries are skipped. Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\"\n\nPrototype\n\nbool aws_query_string_next_param(struct aws_byte_cursor query_string, struct aws_uri_param *param);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_query_string_params-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_query_string_params","text":"aws_query_string_params(query_string, out_params)\n\nParses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param. The user is also responsible for cleaning up out_params when finished.\n\nPrototype\n\nint aws_query_string_params(struct aws_byte_cursor query_string, struct aws_array_list *out_params);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_raise_error-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_raise_error","text":"aws_raise_error(err)\n\nRaises err to the installed callbacks, and sets the thread's error.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_raise_error(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_raise_error_private-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_raise_error_private","text":"aws_raise_error_private(err)\n\nInternal implementation detail.\n\nPrototype\n\nvoid aws_raise_error_private(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_read_u16-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_read_u16","text":"aws_read_u16(buffer)\n\nExtracts a 16 bit unsigned integer from buffer. Ensures conversion from network byte order to host byte order. Assumes buffer is at least 2 bytes long.\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_read_u16(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_read_u24-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_read_u24","text":"aws_read_u24(buffer)\n\nExtracts a 24 bit unsigned integer from buffer. Ensures conversion from network byte order to host byte order. Assumes buffer is at least 3 bytes long.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_read_u24(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_read_u32-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_read_u32","text":"aws_read_u32(buffer)\n\nExtracts a 32 bit unsigned integer from buffer. Ensures conversion from network byte order to host byte order. Assumes the buffer size is at least 4 bytes.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_read_u32(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_read_u64-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_read_u64","text":"aws_read_u64(buffer)\n\nExtracts a 64 bit unsigned integer from buffer. Ensures conversion from network byte order to host byte order. Assumes buffer size is at least 8 bytes.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_read_u64(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ref_count_acquire-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ref_count_acquire","text":"aws_ref_count_acquire(ref_count)\n\nIncrements a ref-counter's ref count\n\nArguments\n\nref_count: ref-counter to increment the count for\n\nReturns\n\nthe object being ref-counted\n\nPrototype\n\nvoid *aws_ref_count_acquire(struct aws_ref_count *ref_count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ref_count_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_ref_count_init","text":"aws_ref_count_init(ref_count, object, on_zero_fn)\n\nInitializes a ref-counter structure. After initialization, the ref count will be 1.\n\nArguments\n\nref_count: ref-counter to initialize\nobject: object being ref counted\non_zero_fn: function to invoke when the ref count reaches zero\n\nPrototype\n\nvoid aws_ref_count_init( struct aws_ref_count *ref_count, void *object, aws_simple_completion_callback *on_zero_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ref_count_release-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ref_count_release","text":"aws_ref_count_release(ref_count)\n\nDecrements a ref-counter's ref count. Invokes the on_zero callback if the ref count drops to zero\n\nArguments\n\nref_count: ref-counter to decrement the count for\n\nReturns\n\nthe value of the decremented ref count\n\nPrototype\n\nsize_t aws_ref_count_release(struct aws_ref_count *ref_count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_register_error_info-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_register_error_info","text":"aws_register_error_info(error_info)\n\nTODO: this needs to be a private function (wait till we have the cmake story better before moving it though). It should be external for the purpose of other libs we own, but customers should not be able to hit it without going out of their way to do so.\n\nPrototype\n\nvoid aws_register_error_info(const struct aws_error_info_list *error_info);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_register_log_subject_info_list-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_register_log_subject_info_list","text":"aws_register_log_subject_info_list(log_subject_list)\n\nConnects log subject strings with log subject integer values\n\nPrototype\n\nvoid aws_register_log_subject_info_list(struct aws_log_subject_info_list *log_subject_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_reset_error-Tuple{}","page":"Home","title":"LibAwsCommon.aws_reset_error","text":"aws_reset_error()\n\nResets the err back to defaults\n\nPrototype\n\nvoid aws_reset_error(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_restore_error-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_restore_error","text":"aws_restore_error(err)\n\nSets err to the latest error. Does not invoke callbacks.\n\nPrototype\n\nvoid aws_restore_error(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_acquire-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_acquire","text":"aws_ring_buffer_acquire(ring_buf, requested_size, dest)\n\nAttempts to acquire requested_size buffer and stores the result in dest if successful. Returns AWS_OP_SUCCESS if the requested size was available for use, AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_ring_buffer_acquire( struct aws_ring_buffer *ring_buf, size_t requested_size, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_acquire_up_to-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_acquire_up_to","text":"aws_ring_buffer_acquire_up_to(ring_buf, minimum_size, requested_size, dest)\n\nAttempts to acquire requested_size buffer and stores the result in dest if successful. If not available, it will attempt to acquire anywhere from 1 byte to requested_size. Returns AWS_OP_SUCCESS if some buffer space is available for use, AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_ring_buffer_acquire_up_to( struct aws_ring_buffer *ring_buf, size_t minimum_size, size_t requested_size, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_buf_belongs_to_pool-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_buf_belongs_to_pool","text":"aws_ring_buffer_buf_belongs_to_pool(ring_buffer, buf)\n\nReturns true if the memory in buf was vended by this ring buffer, false otherwise. Make sure buf->buffer and ring\\_buffer->allocation refer to the same memory region.\n\nPrototype\n\nbool aws_ring_buffer_buf_belongs_to_pool( const struct aws_ring_buffer *ring_buffer, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_check_atomic_ptr-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_check_atomic_ptr","text":"aws_ring_buffer_check_atomic_ptr(ring_buf, atomic_ptr)\n\nChecks whether atomic_ptr correctly points to a memory location within the bounds of the aws_ring_buffer\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_ring_buffer_check_atomic_ptr( const struct aws_ring_buffer *ring_buf, const uint8_t *atomic_ptr);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_clean_up","text":"aws_ring_buffer_clean_up(ring_buf)\n\nCleans up the ring buffer's resources.\n\nPrototype\n\nvoid aws_ring_buffer_clean_up(struct aws_ring_buffer *ring_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_init","text":"aws_ring_buffer_init(ring_buf, allocator, size)\n\nInitializes a ring buffer with an allocation of size size. Returns AWS_OP_SUCCESS on a successful initialization, AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_ring_buffer_init(struct aws_ring_buffer *ring_buf, struct aws_allocator *allocator, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_is_empty-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_is_empty","text":"aws_ring_buffer_is_empty(ring_buf)\n\nChecks whether the ring buffer is empty\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_ring_buffer_is_empty(const struct aws_ring_buffer *ring_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_is_valid","text":"aws_ring_buffer_is_valid(ring_buf)\n\nEvaluates the set of properties that define the shape of all valid aws_ring_buffer structures. It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion).\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_ring_buffer_is_valid(const struct aws_ring_buffer *ring_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_ring_buffer_release-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_ring_buffer_release","text":"aws_ring_buffer_release(ring_buffer, buf)\n\nReleases buf back to the ring buffer for further use. RELEASE MUST HAPPEN in the SAME ORDER AS ACQUIRE. If you do not, your application, and possibly computers within a thousand mile radius, may die terrible deaths, and the local drinking water will be poisoned for generations with fragments of what is left of your radioactive corrupted memory.\n\nPrototype\n\nvoid aws_ring_buffer_release(struct aws_ring_buffer *ring_buffer, struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_round_up_to_power_of_two-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_round_up_to_power_of_two","text":"aws_round_up_to_power_of_two(n, result)\n\nFunction to find the smallest result that is power of 2 >= n. Returns AWS_OP_ERR if this cannot be done without overflow\n\nPrototype\n\nAWS_STATIC_IMPL int aws_round_up_to_power_of_two(size_t n, size_t *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_run_command-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_run_command","text":"aws_run_command(allocator, options, result)\n\nCurrently this API is implemented using popen on Posix system and _popen on Windows to capture output from running a command. Note that popen only captures stdout, and doesn't provide an option to capture stderr. We will add more options, such as acquire stderr in the future so probably will alter the underlying implementation as well.\n\nPrototype\n\nint aws_run_command( struct aws_allocator *allocator, struct aws_run_command_options *options, struct aws_run_command_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_run_command_result_cleanup-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_run_command_result_cleanup","text":"aws_run_command_result_cleanup(result)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_run_command_result_cleanup(struct aws_run_command_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_run_command_result_init-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_run_command_result_init","text":"aws_run_command_result_init(allocator, result)\n\nDocumentation not found.\n\nPrototype\n\nint aws_run_command_result_init(struct aws_allocator *allocator, struct aws_run_command_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_clean_up","text":"aws_rw_lock_clean_up(lock)\n\nCleans up internal resources.\n\nPrototype\n\nvoid aws_rw_lock_clean_up(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_init-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_init","text":"aws_rw_lock_init(lock)\n\nInitializes a new platform instance of mutex.\n\nPrototype\n\nint aws_rw_lock_init(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_rlock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_rlock","text":"aws_rw_lock_rlock(lock)\n\nBlocks until it acquires the lock. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n\nPrototype\n\nint aws_rw_lock_rlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_runlock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_runlock","text":"aws_rw_lock_runlock(lock)\n\nReleases the lock.\n\nPrototype\n\nint aws_rw_lock_runlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_try_rlock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_try_rlock","text":"aws_rw_lock_try_rlock(lock)\n\nAttempts to acquire the lock but returns immediately if it can not. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be. Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]\n\nPrototype\n\nint aws_rw_lock_try_rlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_try_wlock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_try_wlock","text":"aws_rw_lock_try_wlock(lock)\n\nDocumentation not found.\n\nPrototype\n\nint aws_rw_lock_try_wlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_wlock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_wlock","text":"aws_rw_lock_wlock(lock)\n\nDocumentation not found.\n\nPrototype\n\nint aws_rw_lock_wlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_rw_lock_wunlock-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_rw_lock_wunlock","text":"aws_rw_lock_wunlock(lock)\n\nDocumentation not found.\n\nPrototype\n\nint aws_rw_lock_wunlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_secure_strlen-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_secure_strlen","text":"aws_secure_strlen(str, max_read_len, str_len)\n\nComputes the length of a c string in bytes assuming the character set is either ASCII or UTF-8. If no NULL character is found within max_read_len of str, AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED is raised. Otherwise, str_len will contain the string length minus the NULL character, and AWS_OP_SUCCESS will be returned.\n\nPrototype\n\nint aws_secure_strlen(const char *str, size_t max_read_len, size_t *str_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_secure_zero-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_secure_zero","text":"aws_secure_zero(pBuf, bufsize)\n\nSecurely zeroes a memory buffer. This function will attempt to ensure that the compiler will not optimize away this zeroing operation.\n\nPrototype\n\nvoid aws_secure_zero(void *pBuf, size_t bufsize);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_set_environment_value-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_set_environment_value","text":"aws_set_environment_value(variable_name, value)\n\nSet the value of an environment variable. On Windows, setting a variable to the empty string will actually unset it. Not thread-safe\n\nPrototype\n\nint aws_set_environment_value(const struct aws_string *variable_name, const struct aws_string *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_set_global_error_handler_fn-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_set_global_error_handler_fn","text":"aws_set_global_error_handler_fn(handler, ctx)\n\nSets an application wide error handler function. This will be overridden by the thread local handler. The previous handler is returned, this can be used for restoring an error handler if it needs to be overridden temporarily. Setting this to NULL will turn off this error callback after it has been enabled.\n\nPrototype\n\naws_error_handler_fn *aws_set_global_error_handler_fn(aws_error_handler_fn *handler, void *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_set_soft_limit_io_handles-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_set_soft_limit_io_handles","text":"aws_set_soft_limit_io_handles(max_handles)\n\nSets the new soft limit for io_handles (max fds). This can be up to the hard limit but may not exceed it.\n\nThis operation will always fail with AWS_ERROR_UNIMPLEMENTED error code on Windows.\n\nPrototype\n\nint aws_set_soft_limit_io_handles(size_t max_handles);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_set_thread_local_error_handler_fn-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_set_thread_local_error_handler_fn","text":"aws_set_thread_local_error_handler_fn(handler, ctx)\n\nSets a thread-local error handler function. This will override the global handler. The previous handler is returned, this can be used for restoring an error handler if it needs to be overridden temporarily. Setting this to NULL will turn off this error callback after it has been enabled.\n\nPrototype\n\naws_error_handler_fn *aws_set_thread_local_error_handler_fn(aws_error_handler_fn *handler, void *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_small_block_allocator_bytes_active-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_small_block_allocator_bytes_active","text":"aws_small_block_allocator_bytes_active(sba_allocator)\n\nReturns the number of bytes currently active in the SBA\n\nPrototype\n\nsize_t aws_small_block_allocator_bytes_active(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_small_block_allocator_bytes_reserved-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_small_block_allocator_bytes_reserved","text":"aws_small_block_allocator_bytes_reserved(sba_allocator)\n\nReturns the number of bytes reserved in pages/bins inside the SBA, e.g. the current system memory used by the SBA\n\nPrototype\n\nsize_t aws_small_block_allocator_bytes_reserved(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_small_block_allocator_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_small_block_allocator_destroy","text":"aws_small_block_allocator_destroy(sba_allocator)\n\nDestroys a Small Block Allocator instance and frees its memory to the parent allocator. The parent allocator will otherwise be unaffected.\n\nPrototype\n\nvoid aws_small_block_allocator_destroy(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_small_block_allocator_new-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_small_block_allocator_new","text":"aws_small_block_allocator_new(allocator, multi_threaded)\n\nCreates a new Small Block Allocator which fronts the supplied parent allocator. The SBA will intercept and handle small allocs, and will forward anything larger to the parent allocator. If multi_threaded is true, the internal allocator will protect its internal data structures with a mutex\n\nPrototype\n\nstruct aws_allocator *aws_small_block_allocator_new(struct aws_allocator *allocator, bool multi_threaded);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_small_block_allocator_page_size-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_small_block_allocator_page_size","text":"aws_small_block_allocator_page_size(sba_allocator)\n\nReturns the page size that the SBA is using\n\nPrototype\n\nsize_t aws_small_block_allocator_page_size(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_small_block_allocator_page_size_available-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_small_block_allocator_page_size_available","text":"aws_small_block_allocator_page_size_available(sba_allocator)\n\nReturns the amount of memory in each page available to user allocations\n\nPrototype\n\nsize_t aws_small_block_allocator_page_size_available(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_bytes-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_string_bytes","text":"aws_string_bytes(str)\n\nEquivalent to str->bytes.\n\nPrototype\n\nAWS_STATIC_IMPL const uint8_t *aws_string_bytes(const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_c_str-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_string_c_str","text":"aws_string_c_str(str)\n\nEquivalent to (const char *)str->bytes.\n\nPrototype\n\nAWS_STATIC_IMPL const char *aws_string_c_str(const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_clone_or_reuse-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_clone_or_reuse","text":"aws_string_clone_or_reuse(allocator, str)\n\nIf the string was dynamically allocated, clones it. If the string was statically allocated (i.e. has no allocator), returns the original string.\n\nPrototype\n\nstruct aws_string *aws_string_clone_or_reuse(struct aws_allocator *allocator, const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_compare-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_compare","text":"aws_string_compare(a, b)\n\nCompares lexicographical ordering of two strings. This is a binary byte-by-byte comparison, treating bytes as unsigned integers. It is suitable for either textual or binary data and is unaware of unicode or any other byte encoding. If both strings are identical in the bytes of the shorter string, then the longer string is lexicographically after the shorter.\n\nReturns a positive number if string a > string b. (i.e., string a is lexicographically after string b.) Returns zero if string a = string b. Returns negative number if string a < string b.\n\nPrototype\n\nint aws_string_compare(const struct aws_string *a, const struct aws_string *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_string_destroy","text":"aws_string_destroy(str)\n\nDeallocate string.\n\nPrototype\n\nvoid aws_string_destroy(struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_destroy_secure-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_string_destroy_secure","text":"aws_string_destroy_secure(str)\n\nZeroes out the data bytes of string and then deallocates the memory. Not safe to run on a string created with AWS_STATIC_STRING_FROM_LITERAL.\n\nPrototype\n\nvoid aws_string_destroy_secure(struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq","text":"aws_string_eq(a, b)\n\nReturns true if bytes of string are the same, false otherwise.\n\nPrototype\n\nbool aws_string_eq(const struct aws_string *a, const struct aws_string *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq_byte_buf-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq_byte_buf","text":"aws_string_eq_byte_buf(str, buf)\n\nReturns true if bytes of string and buffer are the same, false otherwise.\n\nPrototype\n\nbool aws_string_eq_byte_buf(const struct aws_string *str, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq_byte_buf_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq_byte_buf_ignore_case","text":"aws_string_eq_byte_buf_ignore_case(str, buf)\n\nReturns true if bytes of string and buffer are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_byte_buf_ignore_case(const struct aws_string *str, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq_byte_cursor-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq_byte_cursor","text":"aws_string_eq_byte_cursor(str, cur)\n\nReturns true if bytes of string and cursor are the same, false otherwise.\n\nPrototype\n\nbool aws_string_eq_byte_cursor(const struct aws_string *str, const struct aws_byte_cursor *cur);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq_byte_cursor_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq_byte_cursor_ignore_case","text":"aws_string_eq_byte_cursor_ignore_case(str, cur)\n\nReturns true if bytes of string and cursor are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_byte_cursor_ignore_case(const struct aws_string *str, const struct aws_byte_cursor *cur);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq_c_str","text":"aws_string_eq_c_str(str, c_str)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_string_eq_c_str(const struct aws_string *str, const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq_c_str_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq_c_str_ignore_case","text":"aws_string_eq_c_str_ignore_case(str, c_str)\n\nReturns true if bytes of strings are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_c_str_ignore_case(const struct aws_string *str, const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_eq_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_eq_ignore_case","text":"aws_string_eq_ignore_case(a, b)\n\nReturns true if bytes of string are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_ignore_case(const struct aws_string *a, const struct aws_string *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_string_is_valid","text":"aws_string_is_valid(str)\n\nEvaluates the set of properties that define the shape of all valid aws_string structures. It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion).\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_string_is_valid(const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_new_from_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_new_from_array","text":"aws_string_new_from_array(allocator, bytes, len)\n\nAllocate a new string with the same contents as array.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_array(struct aws_allocator *allocator, const uint8_t *bytes, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_new_from_buf-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_new_from_buf","text":"aws_string_new_from_buf(allocator, buf)\n\nAllocate a new string with the same contents as buf.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_buf(struct aws_allocator *allocator, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_new_from_c_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_new_from_c_str","text":"aws_string_new_from_c_str(allocator, c_str)\n\nConstructor functions which copy data from null-terminated C-string or array of bytes.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_c_str(struct aws_allocator *allocator, const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_new_from_cursor-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_new_from_cursor","text":"aws_string_new_from_cursor(allocator, cursor)\n\nAllocate a new string with the same contents as cursor.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_cursor(struct aws_allocator *allocator, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_new_from_string-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_new_from_string","text":"aws_string_new_from_string(allocator, str)\n\nAllocate a new string with the same contents as another string.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_string(struct aws_allocator *allocator, const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_string_to_log_level-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_string_to_log_level","text":"aws_string_to_log_level(level_string, log_level)\n\nConverts a c-string constant to a log level value. Uses case-insensitive comparison and simply iterates all possibilities until a match or nothing remains. If no match is found, AWS_OP_ERR is returned.\n\nPrototype\n\nint aws_string_to_log_level(const char *level_string, enum aws_log_level *log_level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_sub_size_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_sub_size_checked","text":"aws_sub_size_checked(a, b, r)\n\nIf a - b overflows, returns AWS_OP_ERR; otherwise subtracts a - b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_sub_size_checked(size_t a, size_t b, size_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_sub_size_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_sub_size_saturating","text":"aws_sub_size_saturating(a, b)\n\nSubtracts a - b. If the result overflows returns 0.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_sub_size_saturating(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_sub_u32_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_sub_u32_checked","text":"aws_sub_u32_checked(a, b, r)\n\nIf a - b overflows, returns AWS_OP_ERR; otherwise subtracts a - b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_sub_u32_checked(uint32_t a, uint32_t b, uint32_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_sub_u32_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_sub_u32_saturating","text":"aws_sub_u32_saturating(a, b)\n\nSubtracts a - b. If the result overflows returns 0.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_sub_u32_saturating(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_sub_u64_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_sub_u64_checked","text":"aws_sub_u64_checked(a, b, r)\n\nIf a - b overflows, returns AWS_OP_ERR; otherwise subtracts a - b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_sub_u64_checked(uint64_t a, uint64_t b, uint64_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_sub_u64_saturating-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_sub_u64_saturating","text":"aws_sub_u64_saturating(a, b)\n\nSubtracts a - b. If the result overflows returns 0.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_sub_u64_saturating(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_sys_clock_get_ticks-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_sys_clock_get_ticks","text":"aws_sys_clock_get_ticks(timestamp)\n\nGet ticks in nanoseconds (usually 100 nanosecond precision) on the system clock. Reflects actual system time via nanoseconds since unix epoch. Use with care since an inaccurately set clock will probably cause bugs. On success, timestamp will be set.\n\nPrototype\n\nint aws_sys_clock_get_ticks(uint64_t *timestamp);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_environment_acquire-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_system_environment_acquire","text":"aws_system_environment_acquire(env)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_system_environment *aws_system_environment_acquire(struct aws_system_environment *env);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_environment_get_cpu_group_count-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_system_environment_get_cpu_group_count","text":"aws_system_environment_get_cpu_group_count(env)\n\nReturns the number of separate cpu groupings (multi-socket configurations or NUMA).\n\nPrototype\n\nsize_t aws_system_environment_get_cpu_group_count(const struct aws_system_environment *env);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_environment_get_processor_count-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_system_environment_get_processor_count","text":"aws_system_environment_get_processor_count(env)\n\nReturns the number of processors for the specified compute environment.\n\nPrototype\n\nsize_t aws_system_environment_get_processor_count(struct aws_system_environment *env);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_environment_get_virtualization_product_name-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_system_environment_get_virtualization_product_name","text":"aws_system_environment_get_virtualization_product_name(env)\n\nReturns the product name for the specified compute environment. For example, the Amazon EC2 Instance type.\n\nThe return value may be empty and in that case no vendor was detected.\n\nPrototype\n\nstruct aws_byte_cursor aws_system_environment_get_virtualization_product_name(const struct aws_system_environment *env);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_environment_get_virtualization_vendor-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_system_environment_get_virtualization_vendor","text":"aws_system_environment_get_virtualization_vendor(env)\n\nReturns the virtualization vendor for the specified compute environment, e.g. \"Xen, Amazon EC2, etc...\"\n\nThe return value may be empty and in that case no vendor was detected.\n\nPrototype\n\nstruct aws_byte_cursor aws_system_environment_get_virtualization_vendor(const struct aws_system_environment *env);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_environment_load-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_system_environment_load","text":"aws_system_environment_load(allocator)\n\nAllocates and initializes information about the system the current process is executing on. If successful returns an instance of aws_system_environment. If it fails, it will return NULL.\n\nNote: This api is used internally and is still early in its evolution. It may change in incompatible ways in the future.\n\nPrototype\n\nstruct aws_system_environment *aws_system_environment_load(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_environment_release-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_system_environment_release","text":"aws_system_environment_release(env)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_system_environment_release(struct aws_system_environment *env);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_system_info_processor_count-Tuple{}","page":"Home","title":"LibAwsCommon.aws_system_info_processor_count","text":"aws_system_info_processor_count()\n\nReturns the number of online processors available for usage.\n\nPrototype\n\nsize_t aws_system_info_processor_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_init-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_task_init","text":"aws_task_init(task, fn, arg, type_tag)\n\nInit an aws_task\n\nPrototype\n\nvoid aws_task_init(struct aws_task *task, aws_task_fn *fn, void *arg, const char *type_tag);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_run-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_task_run","text":"aws_task_run(task, status)\n\nRuns or cancels a task\n\nPrototype\n\nvoid aws_task_run(struct aws_task *task, enum aws_task_status status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_cancel_task-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_cancel_task","text":"aws_task_scheduler_cancel_task(scheduler, task)\n\nRemoves task from the scheduler and invokes the task with the AWS_TASK_STATUS_CANCELED status.\n\nPrototype\n\nvoid aws_task_scheduler_cancel_task(struct aws_task_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_clean_up","text":"aws_task_scheduler_clean_up(scheduler)\n\nEmpties and executes all queued tasks, passing the AWS_TASK_STATUS_CANCELED status to the task function. Cleans up any memory allocated, and prepares the instance for reuse or deletion.\n\nPrototype\n\nvoid aws_task_scheduler_clean_up(struct aws_task_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_has_tasks-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_has_tasks","text":"aws_task_scheduler_has_tasks(scheduler, next_task_time)\n\nReturns whether the scheduler has any scheduled tasks. next_task_time (optional) will be set to time of the next task, note that 0 will be set if tasks were added via aws_task_scheduler_schedule_now() and UINT64_MAX will be set if no tasks are scheduled at all.\n\nPrototype\n\nbool aws_task_scheduler_has_tasks(const struct aws_task_scheduler *scheduler, uint64_t *next_task_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_init-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_init","text":"aws_task_scheduler_init(scheduler, alloc)\n\nInitializes a task scheduler instance.\n\nPrototype\n\nint aws_task_scheduler_init(struct aws_task_scheduler *scheduler, struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_is_valid-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_is_valid","text":"aws_task_scheduler_is_valid(scheduler)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_task_scheduler_is_valid(const struct aws_task_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_run_all-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_run_all","text":"aws_task_scheduler_run_all(scheduler, current_time)\n\nSequentially execute all tasks scheduled to run at, or before current_time. AWS_TASK_STATUS_RUN_READY will be passed to the task function as the task status.\n\nIf a task schedules another task, the new task will not be executed until the next call to this function.\n\nPrototype\n\nvoid aws_task_scheduler_run_all(struct aws_task_scheduler *scheduler, uint64_t current_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_schedule_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_schedule_future","text":"aws_task_scheduler_schedule_future(scheduler, task, time_to_run)\n\nSchedules a task to run at time_to_run. The task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_task_scheduler_schedule_future( struct aws_task_scheduler *scheduler, struct aws_task *task, uint64_t time_to_run);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_scheduler_schedule_now-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_task_scheduler_schedule_now","text":"aws_task_scheduler_schedule_now(scheduler, task)\n\nSchedules a task to run immediately. The task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_task_scheduler_schedule_now(struct aws_task_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_task_status_to_c_str-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_task_status_to_c_str","text":"aws_task_status_to_c_str(status)\n\nConvert a status value to a c-string suitable for logging\n\nPrototype\n\nconst char *aws_task_status_to_c_str(enum aws_task_status status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_text_detect_encoding-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_text_detect_encoding","text":"aws_text_detect_encoding(bytes, size)\n\nChecks the BOM in the buffer to see if encoding can be determined. If there is no BOM or it is unrecognizable, then AWS_TEXT_UNKNOWN will be returned.\n\nPrototype\n\nAWS_STATIC_IMPL enum aws_text_encoding aws_text_detect_encoding(const uint8_t *bytes, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_text_is_utf8-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_text_is_utf8","text":"aws_text_is_utf8(bytes, size)\n\nReturns true if aws_text_detect_encoding() determines the text is UTF8 or ASCII. Note that this immediately returns true if the UTF8 BOM is seen. To fully validate every byte, use aws_decode_utf8().\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_text_is_utf8(const uint8_t *bytes, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_call_once-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_call_once","text":"aws_thread_call_once(flag, call_once, user_data)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_thread_call_once(aws_thread_once *flag, void (*call_once)(void *), void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_clean_up","text":"aws_thread_clean_up(thread)\n\nCleans up the thread handle. Don't call this on a managed thread. If you wish to join the thread, you must join before calling this function.\n\nPrototype\n\nvoid aws_thread_clean_up(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_current_at_exit-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_current_at_exit","text":"aws_thread_current_at_exit(callback, user_data)\n\nAdds a callback to the chain to be called when the current thread joins. Callbacks are called from the current thread, in the reverse order they were added, after the thread function returns. If not called from within an aws_thread, has no effect.\n\nPrototype\n\nint aws_thread_current_at_exit(aws_thread_atexit_fn *callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_current_name-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_current_name","text":"aws_thread_current_name(allocator, out_name)\n\nGets name of the current thread. Caller is responsible for destroying returned string. If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is set to NULL. If underlying OS call fails, AWS_ERROR_SYS_CALL_FAILURE will be raised If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED will be raised\n\nPrototype\n\nint aws_thread_current_name(struct aws_allocator *allocator, struct aws_string **out_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_current_sleep-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_current_sleep","text":"aws_thread_current_sleep(nanos)\n\nSleeps the current thread by nanos.\n\nPrototype\n\nvoid aws_thread_current_sleep(uint64_t nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_current_thread_id-Tuple{}","page":"Home","title":"LibAwsCommon.aws_thread_current_thread_id","text":"aws_thread_current_thread_id()\n\nReturns the thread id of the calling thread.\n\nPrototype\n\naws_thread_id_t aws_thread_current_thread_id(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_decrement_unjoined_count-Tuple{}","page":"Home","title":"LibAwsCommon.aws_thread_decrement_unjoined_count","text":"aws_thread_decrement_unjoined_count()\n\nDecrements the count of unjoined threads in the managed thread system. Used by managed threads and event loop threads. Additional usage requires the user to join corresponding threads themselves and correctly increment/decrement even in the face of launch/join errors.\n\naws_thread_join_all_managed() will not return until this count has gone to zero.\n\nPrototype\n\nvoid aws_thread_decrement_unjoined_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_get_detach_state-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_get_detach_state","text":"aws_thread_get_detach_state(thread)\n\nGets the detach state of the thread. For example, is it safe to call join on this thread? Has it been detached()?\n\nPrototype\n\nenum aws_thread_detach_state aws_thread_get_detach_state(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_get_id-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_get_id","text":"aws_thread_get_id(thread)\n\nGets the id of thread\n\nPrototype\n\naws_thread_id_t aws_thread_get_id(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_id_t_to_string-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_id_t_to_string","text":"aws_thread_id_t_to_string(thread_id, buffer, bufsz)\n\nConverts an aws_thread_id_t to a c-string. For portability, aws_thread_id_t must not be printed directly. Intended primarily to support building log lines that include the thread id in them. The parameter buffer must point-to a char buffer of length bufsz == [AWSTHREADIDTREPR_BUFSZ](@ref). The thread id representation is returned in buffer.\n\nPrototype\n\nint aws_thread_id_t_to_string(aws_thread_id_t thread_id, char *buffer, size_t bufsz);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_increment_unjoined_count-Tuple{}","page":"Home","title":"LibAwsCommon.aws_thread_increment_unjoined_count","text":"aws_thread_increment_unjoined_count()\n\nIncrements the count of unjoined threads in the managed thread system. Used by managed threads and event loop threads. Additional usage requires the user to join corresponding threads themselves and correctly increment/decrement even in the face of launch/join errors.\n\naws_thread_join_all_managed() will not return until this count has gone to zero.\n\nPrototype\n\nvoid aws_thread_increment_unjoined_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_init-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_init","text":"aws_thread_init(thread, allocator)\n\nInitializes a new platform specific thread object struct (not the os-level thread itself).\n\nPrototype\n\nint aws_thread_init(struct aws_thread *thread, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_join-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_join","text":"aws_thread_join(thread)\n\nJoins the calling thread to a thread instance. Returns when thread is finished. Calling this from the associated OS thread will cause a deadlock.\n\nPrototype\n\nint aws_thread_join(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_join_all_managed-Tuple{}","page":"Home","title":"LibAwsCommon.aws_thread_join_all_managed","text":"aws_thread_join_all_managed()\n\nBlocking call that waits for all managed threads to complete their join call. This can only be called from the main thread or a non-managed thread.\n\nThis gets called automatically from library cleanup.\n\nBy default the wait is unbounded, but that default can be overridden via aws_thread_set_managed_join_timeout_ns()\n\nPrototype\n\nint aws_thread_join_all_managed(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_launch-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_thread_launch","text":"aws_thread_launch(thread, func, arg, options)\n\nCreates an OS level thread and associates it with func. context will be passed to func when it is executed. options will be applied to the thread if they are applicable for the platform.\n\nAfter launch, you may join on the thread. A successfully launched thread must have clean_up called on it in order to avoid a handle leak. If you do not join before calling clean_up, the thread will become detached.\n\nManaged threads must not have join or clean_up called on them by external code.\n\nPrototype\n\nint aws_thread_launch( struct aws_thread *thread, void (*func)(void *arg), void *arg, const struct aws_thread_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_name-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_name","text":"aws_thread_name(allocator, thread_id, out_name)\n\nGets name of the thread. Caller is responsible for destroying returned string. If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is set to NULL. If underlying OS call fails, AWS_ERROR_SYS_CALL_FAILURE will be raised If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED will be raised\n\nPrototype\n\nint aws_thread_name( struct aws_allocator *allocator, aws_thread_id_t thread_id, struct aws_string **out_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_scheduler_acquire-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_scheduler_acquire","text":"aws_thread_scheduler_acquire(scheduler)\n\nAcquire a reference to the scheduler.\n\nPrototype\n\nvoid aws_thread_scheduler_acquire(struct aws_thread_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_scheduler_cancel_task-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_scheduler_cancel_task","text":"aws_thread_scheduler_cancel_task(scheduler, task)\n\nCancel a task that has been scheduled. The cancellation callback will be invoked in the background thread. This function is slow, so please don't do it in the hot path for your code.\n\nPrototype\n\nvoid aws_thread_scheduler_cancel_task(struct aws_thread_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_scheduler_new-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_scheduler_new","text":"aws_thread_scheduler_new(allocator, thread_options)\n\nCreates a new instance of a thread scheduler. This object receives scheduled tasks and executes them inside a background thread. On success, this function returns an instance with a ref-count of 1. On failure it returns NULL.\n\nthread_options are optional.\n\nThe semantics of this interface conform to the semantics of aws_task_scheduler.\n\nPrototype\n\nstruct aws_thread_scheduler *aws_thread_scheduler_new( struct aws_allocator *allocator, const struct aws_thread_options *thread_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_scheduler_release-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_scheduler_release","text":"aws_thread_scheduler_release(scheduler)\n\nRelease a reference to the scheduler.\n\nPrototype\n\nvoid aws_thread_scheduler_release(const struct aws_thread_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_scheduler_schedule_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_scheduler_schedule_future","text":"aws_thread_scheduler_schedule_future(scheduler, task, time_to_run)\n\nSchedules a task to run in the future. time_to_run is the absolute time from the system hw_clock.\n\nPrototype\n\nvoid aws_thread_scheduler_schedule_future( struct aws_thread_scheduler *scheduler, struct aws_task *task, uint64_t time_to_run);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_scheduler_schedule_now-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_scheduler_schedule_now","text":"aws_thread_scheduler_schedule_now(scheduler, task)\n\nSchedules a task to run as soon as possible.\n\nPrototype\n\nvoid aws_thread_scheduler_schedule_now(struct aws_thread_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_set_managed_join_timeout_ns-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_thread_set_managed_join_timeout_ns","text":"aws_thread_set_managed_join_timeout_ns(timeout_in_ns)\n\nOverrides how long, in nanoseconds, that aws_thread_join_all_managed will wait for threads to complete. A value of zero will result in an unbounded wait.\n\nPrototype\n\nvoid aws_thread_set_managed_join_timeout_ns(uint64_t timeout_in_ns);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_thread_thread_id_equal-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_thread_thread_id_equal","text":"aws_thread_thread_id_equal(t1, t2)\n\nCompare thread ids.\n\nPrototype\n\nbool aws_thread_thread_id_equal(aws_thread_id_t t1, aws_thread_id_t t2);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_timegm-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_timegm","text":"aws_timegm(t)\n\nCross platform friendly version of timegm\n\nPrototype\n\ntime_t aws_timegm(struct tm *const t);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_timestamp_convert-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_timestamp_convert","text":"aws_timestamp_convert(timestamp, convert_from, convert_to, remainder)\n\nConverts 'timestamp' from unit 'convert_from' to unit 'convert_to', if the units are the same then 'timestamp' is returned. If 'remainder' is NOT NULL, it will be set to the remainder if convert_from is a more precise unit than convert_to. To avoid unnecessary branching, 'remainder' is not zero initialized in this function, be sure to set it to 0 first if you care about that kind of thing. If conversion would lead to integer overflow, the timestamp returned will be the highest possible time that is representable, i.e. UINT64_MAX.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_timestamp_convert( uint64_t timestamp, enum aws_timestamp_unit convert_from, enum aws_timestamp_unit convert_to, uint64_t *remainder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_timestamp_convert_u64-NTuple{4, Any}","page":"Home","title":"LibAwsCommon.aws_timestamp_convert_u64","text":"aws_timestamp_convert_u64(ticks, old_frequency, new_frequency, remainder)\n\nMore general form of aws_timestamp_convert that takes arbitrary frequencies rather than the timestamp enum.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_timestamp_convert_u64(uint64_t ticks, uint64_t old_frequency, uint64_t new_frequency, uint64_t *remainder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_translate_and_raise_io_error-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_translate_and_raise_io_error","text":"aws_translate_and_raise_io_error(error_no)\n\nConvert a c library io error into an aws error, and raise it. If no conversion is found, AWS_ERROR_SYS_CALL_FAILURE is raised. Always returns AWS_OP_ERR.\n\nPrototype\n\nint aws_translate_and_raise_io_error(int error_no);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_translate_and_raise_io_error_or-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_translate_and_raise_io_error_or","text":"aws_translate_and_raise_io_error_or(error_no, fallback_aws_error_code)\n\nConvert a c library io error into an aws error, and raise it. If no conversion is found, fallback_aws_error_code is raised. Always returns AWS_OP_ERR.\n\nPrototype\n\nint aws_translate_and_raise_io_error_or(int error_no, int fallback_aws_error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_unregister_error_info-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_unregister_error_info","text":"aws_unregister_error_info(error_info)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_unregister_error_info(const struct aws_error_info_list *error_info);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_unregister_log_subject_info_list-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_unregister_log_subject_info_list","text":"aws_unregister_log_subject_info_list(log_subject_list)\n\nDisconnects log subject strings with log subject integer values\n\nPrototype\n\nvoid aws_unregister_log_subject_info_list(struct aws_log_subject_info_list *log_subject_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_unset_environment_value-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_unset_environment_value","text":"aws_unset_environment_value(variable_name)\n\nUnset an environment variable. Not thread-safe\n\nPrototype\n\nint aws_unset_environment_value(const struct aws_string *variable_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_authority-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_authority","text":"aws_uri_authority(uri)\n\nReturns the authority portion of the uri (host[:port]). If it was not present, this was a request uri. In that case, the value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_authority(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_clean_up-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_clean_up","text":"aws_uri_clean_up(uri)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_uri_clean_up(struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_host_name-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_host_name","text":"aws_uri_host_name(uri)\n\nReturns the 'host_name' portion of the authority. If no authority was present, this value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_host_name(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_init_from_builder_options-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_uri_init_from_builder_options","text":"aws_uri_init_from_builder_options(uri, allocator, options)\n\nInitializes uri to values specified in options. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure. After calling this function, the parts can be accessed.\n\nPrototype\n\nint aws_uri_init_from_builder_options( struct aws_uri *uri, struct aws_allocator *allocator, struct aws_uri_builder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_init_parse-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_uri_init_parse","text":"aws_uri_init_parse(uri, allocator, uri_str)\n\nParses 'uri_str' and initializes uri. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure. After calling this function, the parts can be accessed.\n\nPrototype\n\nint aws_uri_init_parse( struct aws_uri *uri, struct aws_allocator *allocator, const struct aws_byte_cursor *uri_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_path-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_path","text":"aws_uri_path(uri)\n\nReturns the path portion of the uri, including any leading '/'. If not present, this value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_path(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_path_and_query-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_path_and_query","text":"aws_uri_path_and_query(uri)\n\nReturns the path and query portion of the uri (i.e., the thing you send across the wire).\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_path_and_query(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_port-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_port","text":"aws_uri_port(uri)\n\nReturns the port portion of the authority if it was present, otherwise, returns 0. If this is 0, it is the users job to determine the correct port based on scheme and protocol.\n\nPrototype\n\nuint32_t aws_uri_port(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_query_string-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_query_string","text":"aws_uri_query_string(uri)\n\nReturns the query string portion of the uri, minus the '?'. If not present, this value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_query_string(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_query_string_next_param-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_uri_query_string_next_param","text":"aws_uri_query_string_next_param(uri, param)\n\nFor iterating over the params in the uri query string. param is an in/out argument used to track progress, it MUST be zeroed out to start. If true is returned, param contains the value of the next param. If false is returned, there are no further params.\n\nEdge cases: 1) Entries without '=' sign are treated as having a key and no value. Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\nBlank entries are skipped. Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\"\n\nPrototype\n\nbool aws_uri_query_string_next_param(const struct aws_uri *uri, struct aws_uri_param *param);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_query_string_params-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_uri_query_string_params","text":"aws_uri_query_string_params(uri, out_params)\n\nParses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param. The user is also responsible for cleaning up out_params when finished.\n\nPrototype\n\nint aws_uri_query_string_params(const struct aws_uri *uri, struct aws_array_list *out_params);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uri_scheme-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uri_scheme","text":"aws_uri_scheme(uri)\n\nReturns the scheme portion of the uri (e.g. http, https, ftp, ftps, etc...). If the scheme was not present in the uri, the returned value will be empty. It is the users job to determine the appropriate defaults if this field is empty, based on protocol, port, etc...\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_scheme(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_utf8_decoder_destroy-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_utf8_decoder_destroy","text":"aws_utf8_decoder_destroy(decoder)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_utf8_decoder_destroy(struct aws_utf8_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_utf8_decoder_finalize-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_utf8_decoder_finalize","text":"aws_utf8_decoder_finalize(decoder)\n\nTell the decoder that you've reached the end of your text. Raises AWS_ERROR_INVALID_UTF8 if the text did not end with a complete UTF8 codepoint. This also resets the decoder.\n\nPrototype\n\nint aws_utf8_decoder_finalize(struct aws_utf8_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_utf8_decoder_new-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_utf8_decoder_new","text":"aws_utf8_decoder_new(allocator, options)\n\nCreate a UTF8/ASCII decoder, which can process text incrementally as you receive it. Text is always validated according to RFC-3629 (you may perform additional validation in the on_codepoint callback). The text does not need to begin with a UTF8 BOM. To decode text all at once, simply use aws_decode_utf8().\n\nFeed bytes into the decoder with aws_utf8_decoder_update(), and call aws_utf8_decoder_finalize() when the text is complete.\n\nArguments\n\nallocator: Allocator\noptions: Options for decoder. If NULL is passed, the text is simply validated.\n\nPrototype\n\nstruct aws_utf8_decoder *aws_utf8_decoder_new( struct aws_allocator *allocator, const struct aws_utf8_decoder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_utf8_decoder_reset-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_utf8_decoder_reset","text":"aws_utf8_decoder_reset(decoder)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_utf8_decoder_reset(struct aws_utf8_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_utf8_decoder_update-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_utf8_decoder_update","text":"aws_utf8_decoder_update(decoder, bytes)\n\nUpdate the decoder with more bytes of text. The on_codepoint callback will be invoked for each codepoint encountered. Raises an error if invalid UTF8 is encountered or the on_codepoint callback reports an error.\n\nNote: You must call aws_utf8_decoder_finalize() when the text is 100% complete, to ensure the input was completely valid.\n\nPrototype\n\nint aws_utf8_decoder_update(struct aws_utf8_decoder *decoder, struct aws_byte_cursor bytes);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uuid_equals-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_uuid_equals","text":"aws_uuid_equals(a, b)\n\nDocumentation not found.\n\nPrototype\n\nbool aws_uuid_equals(const struct aws_uuid *a, const struct aws_uuid *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uuid_init-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_uuid_init","text":"aws_uuid_init(uuid)\n\nDocumentation not found.\n\nPrototype\n\nint aws_uuid_init(struct aws_uuid *uuid);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uuid_init_from_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_uuid_init_from_str","text":"aws_uuid_init_from_str(uuid, uuid_str)\n\nDocumentation not found.\n\nPrototype\n\nint aws_uuid_init_from_str(struct aws_uuid *uuid, const struct aws_byte_cursor *uuid_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_uuid_to_str-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_uuid_to_str","text":"aws_uuid_to_str(uuid, output)\n\nDocumentation not found.\n\nPrototype\n\nint aws_uuid_to_str(const struct aws_uuid *uuid, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_write_u16-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_write_u16","text":"aws_write_u16(value, buffer)\n\nAdd a 16 bit unsigned integer to the buffer, ensuring network-byte order return the new position in the buffer for the next operation. Assumes buffer is at least 2 bytes long.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u16(uint16_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_write_u24-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_write_u24","text":"aws_write_u24(value, buffer)\n\nAdd a 24 bit unsigned integer to the buffer, ensuring network - byte order return the new position in the buffer for the next operation. Note, since this uses uint32_t for storage, the 3 least significant bytes will be used. Assumes buffer is at least 3 bytes long.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u24(uint32_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_write_u32-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_write_u32","text":"aws_write_u32(value, buffer)\n\nAdd a 32 bit unsigned integer to the buffer, ensuring network - byte order Assumes the buffer size is at least 4 bytes.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u32(uint32_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_write_u64-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_write_u64","text":"aws_write_u64(value, buffer)\n\nAdd a 64 bit unsigned integer to the buffer, ensuring network - byte order Assumes the buffer size is at least 8 bytes.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u64(uint64_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_xml_node_as_body-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_xml_node_as_body","text":"aws_xml_node_as_body(node, out_body)\n\nWrites the contents of the body of node into out_body. out_body is an output parameter in this case. Upon success, out_body will contain the body of the node.\n\nPrototype\n\nint aws_xml_node_as_body(struct aws_xml_node *node, struct aws_byte_cursor *out_body);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_xml_node_get_attribute-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_xml_node_get_attribute","text":"aws_xml_node_get_attribute(node, attribute_index)\n\nGet an attribute for an xml node by its index.\n\nPrototype\n\nstruct aws_xml_attribute aws_xml_node_get_attribute(const struct aws_xml_node *node, size_t attribute_index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_xml_node_get_name-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_xml_node_get_name","text":"aws_xml_node_get_name(node)\n\nGet the name of an xml node.\n\nPrototype\n\nstruct aws_byte_cursor aws_xml_node_get_name(const struct aws_xml_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_xml_node_get_num_attributes-Tuple{Any}","page":"Home","title":"LibAwsCommon.aws_xml_node_get_num_attributes","text":"aws_xml_node_get_num_attributes(node)\n\nGet the number of attributes for an xml node.\n\nPrototype\n\nsize_t aws_xml_node_get_num_attributes(const struct aws_xml_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_xml_node_traverse-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.aws_xml_node_traverse","text":"aws_xml_node_traverse(node, on_node_encountered, user_data)\n\nTraverse node and invoke on_node_encountered when a nested node is encountered.\n\nPrototype\n\nint aws_xml_node_traverse( struct aws_xml_node *node, aws_xml_parser_on_node_encountered_fn *on_node_encountered, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.aws_xml_parse-Tuple{Any, Any}","page":"Home","title":"LibAwsCommon.aws_xml_parse","text":"aws_xml_parse(allocator, options)\n\nParse an XML document. WARNING: This is not a public API. It is only intended for use within the aws-c libraries.\n\nPrototype\n\nint aws_xml_parse(struct aws_allocator *allocator, const struct aws_xml_parser_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.enable_vt_mode-Tuple{}","page":"Home","title":"LibAwsCommon.enable_vt_mode","text":"enable_vt_mode()\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int enable_vt_mode(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.s_aws_run_test_case-Tuple{Any}","page":"Home","title":"LibAwsCommon.s_aws_run_test_case","text":"s_aws_run_test_case(harness)\n\nDocumentation not found.\n\nPrototype\n\nstatic inline int s_aws_run_test_case(struct aws_test_harness *harness);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsCommon.s_print_stack_trace-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsCommon.s_print_stack_trace","text":"s_print_stack_trace(sig, sig_info, user_data)\n\nDocumentation not found.\n\nPrototype\n\nstatic void s_print_stack_trace(int sig, siginfo_t *sig_info, void *user_data);\n\n\n\n\n\n","category":"method"}]
}
